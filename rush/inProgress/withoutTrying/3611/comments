
Сделал метод для получения всех друзей по индексу, а так же вторым параметром индекс, который игнорировался (туда передавал первоначальный индекс из getAllFriendsAndPotentialFriends, чтобы избавиться от возможного повторения нашего индекса, так же вариант просто удалить его из сета в getAllFriendsAndPotentialFriends в конце всех действий).

Решал итеративно. Так как при создании сета я передавал туда сразу всех друзей нашего индекса, то цикл у меня был от 1 до deep. В этом цикле с использованием дополнительной коллекции просто перебирал все элементы сета, для каждого вызвал getAllFriends, и результат этого метода добавлял до сета.
Ответить
0
swen922 37 уровень
4 июля, 19:56
Спасибо odium за картинку! С ней сразу понятнее. 

Решил, по совету Максима, с использованием доп. вспомогательного метода. 
Метод  private Set<Integer> getInsideFriends(int index) точно такой же, как основной, только без указания глубины поиска, соответственно, выдает только друзей указанного индекса. 

Ну а внутри основного метода тогда все просто: если глубина=0, то сразу выдаем результат вспомогательного метода. 
Если глубина более 0, то далее у меня цикл for (int i = 1; i < deep; i++). 
В этом цикле создаем новый сет, копируем в него все значения из основного сета, в который собираем все данные, а затем пробегаем по всем значениям этого внутреннего сета: отправляем их один за другим во вспомогательный метод и копируем все полученные сеты через addAll в основной внешний сет с результатами. 
После окончания цикла не забыть удалить из сета с результатами index (самому с собой дружить нельзя). 

Ошибка в задании действительно есть: задание не соответствует закомментированному тексту в коде, где нам показывают, какие значения должны вывестись. Судя по валидатору, приоритетнее закомментированный код – он ориентир для вывода. Подогнал глубину, указав i=1 в вышеприведенном цикле. Если сделать i=0, то глубина станет больше на уровень, и в список добавится еще один индекс. 
Ответить
0
Fonzy 40 уровень, Москва
26 апреля, 15:40
Вручуную дорисовал массив до "полного" - не приняло. Какого хрена, может мне так удобней?
Ответить
0
Динислам Майлюков 32 уровень
12 мая, 21:53
Ты главное с девушками по аккуратнее с "вручную"...тоже могут не принять xD
Ответить
0
Максим 39 уровень
17 апреля, 21:55
Самое сложное в этой задаче оказалось разобраться в исходном массиве. Долго не мог понять, что это такое вообще) 
Когда разобрался, то решить было не так уж и сложно.
Сначала тоже, как и некоторые тут писали хотел решить через рекурсию, но потом передумал, так как при большой глубине поиска друзей программа зависает. Позже протестировал решение через рекурсию. Например, при вводе deep = 15 программа уже жутко долго работает, а при 20 даже не стал ждать ее завершения. Не знаю или в реальной жизни нужно будет так "глубоко" искать друзей, но все же я решил отказаться от такого способа решения. Вообще стараюсь в задачах избегать рекурсии, ибо, говорят, что это не есть хорошо. Для сравнения, в моем способе решения можно вводить deep хоть миллион, хоть больше и программа отрабатывает за секунды (при данном массиве).
По поводу того, что тут писали, мол, ошибка в условии глубины поиска. Ну я хз. Лично я решал как в условии было сказано. Решение строилось из расчета, что при глубине = 0 выводились только друзья, при =1 друзья друзей и так далее. Из-за этого только код стал больше, а так ничего принципиально не поменялось.
Мой способ решения:
в начале метода находил всех друзей и добавлял их в сет. Затем if(), если deep = 1, то пробегался по друзьям и добавлял их друзей в сет. Чтобы не было concurrentmodificationexception использовал вспомогательный сет.
else в цикле размером deep-1 пробегался по друзьям и добавлял их друзей в сет. Опять же использовал вспомогательный сет. Ну и в конце, естественно, возвращал сет) 
В if и else код идентичный за исключением того, что в else используется цикл.
Если использовать дополнительный метод, то код значительно уменьшается и становится более красивым (и дополнительный сет не нужен). И валидатор хавает такой способ.
Если решать, как тут говорили, что, мол, при deep=1 добавлять только друзей, то код еще меньше и проще. 
Ответить
+1
Сергей Черник 40 уровень
4 мая, 13:50
Очереди - наше все!
Ответить
0
Евгений Пехтерев 40 уровень, Санкт-Петербург
12 апреля, 16:17
мда, потратил лишние полчаса врубаясь, что не так, а оказалось, что в условии неправильно написано на счёт глубины.
Ответить
0
Александр Порохин 30 уровень
2 марта, 11:52
Чем дальше, тем объяснение задач становится непонятнее. Не мог вообще разобраться как связан двумерный массив с друзьями 
Ответить
+7
Сергей 40 уровень
19 февраля, 08:25
Проверял так:
Если (humansRelationships[Math.max(i,index)][Math.min(i,index)])
Ответить
0
Sergey 40 уровень, Киев
2 февраля, 21:49
Сразу начал решать через рекурсию...
Решение в 11 строк...

Алгоритм:
1. Создаем сет.
2. Если deep > 0
       2.1 Цикл от i = 0 до длины humansRelationships 
           2.2.1 Если (i < index и  элемент [index][i] == true)
               - кладем в сет индекс столбца проверяемого элемента -> i
               - кладем в сет (set.addAll) рекурсивный вызов getAllFriendsAndPotentialFriends(индекс столбца 
                 проверяемого элемента, deep - 1)
           2.2.2 Иначе если (i > index и  элемент [i][index] == true)
               - кладем в сет индекс строки проверяемого элемента -> i
               - кладем в сет (set.addAll) рекурсивный вызов - getAllFriendsAndPotentialFriends(индекс строки 
                 проверяемого элемента, deep - 1)
3. Удаляем index из сета.
4. return сет
Ответить
0
Сергей 38 уровень
29 января, 19:50
Даааа уж.....несколько часов мучал эту задачу........долго не мог понять, как устроены эти связи
Ответить
0
Vra 40 уровень
19 декабря 2017, 00:12
"int index - это индекс человека в массиве (начиная с нуля);" 
сразу не дошло - какого человека то?))
короче индекс это и есть человек.. абстракция етить..
4ка дружит с 0, 1, 3
0 дружит с 1, 4, 5
1 дружит с 2, 4
3ка дружит с 4, 7
итого 0, 1, 2, 3, 5, 7 (4ку не берем)
Ответить
+1
odium 40 уровень, Волгоград
8 декабря 2017, 15:42

Картинка для наглядности.
Сразу решайте рекурсией.
Ответить
+3
Юрий 40 уровень, Ульяновск
8 ноября 2017, 14:31
Будьте внимательны  - в условии ошибка глубины поиска.
При глубине 1 должны добавляться только СВОИ друзья.
При 2 - друзья друзей, 3 - друзья друзей друзей и т.д.
Ответить
+4
Санёк Ростовцев 26 уровень
22 декабря 2017, 13:01
Я тоже так думаю.
Ответить
0
Paz1506 40 уровень
20 сентября 2017, 14:08
Хорошая подсказка - уже реализованный метод удаления друзей. Добавление "друзей друзей" сделал при помощи рекурсии.
Ответить
0
Владислав Бауэр 40 уровень, Санкт-Петербург
31 августа 2017, 16:08
Сначала пройти по строке, потом по столбцу.
Если индекс подходит, добавить его и его потенциальных друзей в сет
Ответить
+2
Фёдор Ларионов 38 уровень
9 августа 2017, 19:30
Вставлю свои 5 копеек, потому что сам на пустом месте топтался:

в нашем методе массив отношений берем не из метода generateRelationShips, а из приватной переменной (иначе при правильном выводе не зачтет 4-й пункт)
Ответить
0
Vladimir Saponko 40 уровень, Минск
30 июля 2017, 11:52
1.  Для нахождения всех друзей человека с индексом n нужно сначала пройтись по горизонтальному массиву с индексом n, а затем по вертикальному с тем же индексом. Например, для человека с индексом 1 горизонтальный массив - это true,true , а вертикальный true,true,false,true,false,false,false. Т.е. этот человек дружит с 0, 2 и 4.
2. Насколько я понял, в условии ошибки нет, просто его нужно прочитать много раз)) 
Ответить
0
Vitya 33 уровень, Нижний Новгород
7 июля 2017, 22:40
Как ниже Михаил Гончаренко писал, в условии ошибка. При 1 только свои друзья добавляются.
Как в методе удаления, что бы найти всех друзей i надо проходить и по столбцу и по строке.
Ответить
+1
Владимир Горбатенко 37 уровень, Одесса
11 июня 2017, 11:13
Устал тупить. 10 раз перечитал условие задачи. Не могу я вообразить этот массив как связи дружбы. Просьба показать его в более понятном виде, с именами что ли. Может как в экселе, чтоб картина была полной.
Ответить
0
MaxLich 40 уровень, Санкт-Петербург
10 июня 2017, 13:02
Да, задачка оказалась несложной, но пораскинуть мозгами пришлось. Использовал очередь.
Ответить
0
Simona Hub 35 уровень
1 июня 2017, 22:20
что означает Пересечение столбца и столбика ? кто есть кто?
Ответить
+2
Владимир Горбатенко 37 уровень, Одесса
11 июня 2017, 10:38
тоже подвис на этой фразе...
Ответить
+2
LJ 40 уровень, Екатеринбург
22 мая 2017, 15:15
может кто нибудь разжевать смысл этой задачи, ни как не могу въехать, что то?
почему наш двумерный массив, не полный?
Ответить
0
Simona Hub 35 уровень
1 июня 2017, 22:34
половина таблицы, потому что если Маша дружит с Наташей, то Наташа дружит с Машей (одно и тоже :-)) 
Ответить
+1
MaxLich 40 уровень, Санкт-Петербург
10 июня 2017, 13:03
в итоге матрица просто симметрична относительно этой диагонали (поэтому её и не стали "рисовать" полной).
Ответить
+1
Михаил Гончаренко 40 уровень, Москва
17 февраля 2017, 14:02
В условии ошибка. При глубине поиска 1 не нужно брать друзей друзей.
Ответить
+1
MaxLich 40 уровень, Санкт-Петербург
10 июня 2017, 13:04
да, только друзей. это надо предусмотреть в своём алгоритме.
