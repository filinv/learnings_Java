
Очень понравилась задачка. DOM JAXB Transform
Ответить
0
swen922 37 уровень
12 июня, 12:04
Маленькая закавыка, из-за которой профукал несколько попыток: объект Comment надо создавать внутри цикла обхода узлов, чтобы каждый раз добавлять в документ НОВЫЙ только что созданный объект.

Если же создать объект типа Comment заранее, вне цикла, и потом добавлять его во время обхода узлов, то можно долго недоумевать, почему валидатор не пропускает решение. 
А потому, что в таком случае объект комментария добавляется только один раз, независимо от количества совпавших тагов. Видимо, в Document нельзя добавлять один и тот же объект более одного раза. 
И это НИГДЕ вообще не написано – не заметил ни в одной статье из всех, что перерыл в процессе решения. 

Выявить проблему можно только если в проверочном объекте сделать два или более одинаковых тагов, к которым требуется комментарий – тогда сразу заметно, что чего-то не хватает. 
Но кто ж это мог подумать заранее...  ) 
Ответить
0
cyprusScorpion 37 уровень
7 июня, 14:50
Трансформеру достаточно установить одно свойство (перенос строки):
transformer.setOutputProperty(OutputKeys.INDENT, "yes");

остальные выставляются по умолчанию автоматически, и в консоль выводится как в условии задачи:
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
Ответить
+3
cyprusScorpion 37 уровень
7 июня, 14:45
Проверьте, чтобы CDATA в документе вставлялось внутрь всех тегов, где встречаются "<" ">" "&", а также апостроф ' и кавычки ", а не только внутрь искомого тега tagName ;))
При заполнении параметра "regex" кавычки экранируются обратной косой чертой \, например:

if (currentNode.getTextContent().matches(".*[<>&'\"].*")) { ... }
Ответить
+2
Мистер Исключительный 40 уровень
4 июня, 11:30
Решил через ContentHandler и XMLStreamWriter.
1) Создание реализации ContentHandler
Создаем новый класс и наследуемся от DefaultHandler (дефолтная (пустая по сути) реализация интерфейса ContentHandler)
В конструктор передаем XMLStreamWriter, tagName и comment.
Переопределяем следующие методы:
a) 

public void characters(char[] ch, int start, int length) throws SAXException

Создаем строку из массива:

String data = new String(ch,start,length);

Если наша строка содержит спец. символы

data.matches(".*[<>&'\"].*")

(thx Славиша Мишич) то вызываем у XMLStreamWriter writeCData, иначе writeCharacters. b)

public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException

Тут делаем проверку на совпадение тэга

localName.equals(tagName)

и если совпало, то вызываем у XMLStreamWriter writeComment. Далее у XMLStreamWriter вызываем writeStartElement. Я вызывал с 3 параметрами, префикс выделяем сами. Также записываем аттрибуты с помощью writeAttribute. (Может для прохождения тестов записывать аттрибуты и ненужно) c)

public void endElement(String uri, String localName, String qName) throws SAXException

Просто вызываем writeEndElement у XMLStreamWriter. d)

public void startDocument() throws SAXException

Больше всего проблем возникло именно здесь, ибо как оказалось заголовок xml должен точно совпадать с тем, что в тестах. Здесь просто вызываем следующий метод:

xsw.writeDTD("<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>");

Ответить
0
Мистер Исключительный 40 уровень
4 июня, 11:38
2) Метод toXmlWithComment
a) Создаем XMLStreamWriter

StringWriter result = new StringWriter();
XMLStreamWriter xsw = XMLOutputFactory.newFactory().createXMLStreamWriter(result);

b) Cоздаем объект класса, реализующего ContentHandler (пункт 1) и передаем туда XMLStreamWriter.

MyContetnHandler myContentHandler = new MyContetnHandler(xsw,tagName,comment);

c) При маршаллизации передаем объект из b)

marshaller.marshal(obj, myContentHandler);

Ответить
0
Елизавета Виноградова 35 уровень
28 мая, 13:15
Да по этой задаче нужен отдельный уровень, блин. Про Document с производными, Node и NodeList, CDATA, Transformer... Целый день с утра до вечера убит просто на изучение кучи дополнительной инфы, чтобы решить одну задачку.
Ответить
+1
Vitaly Kurnosenko 24 уровень
22 мая, 17:07
Пытался вставлять комментарии с помощью Node.insertBefore(). При наличии нескольких одинаковых тэгов вставка идет исключительно перед последним из них. Это обычное поведение или может я чего-то не так делаю?
Ответить
0
Vitaly Kurnosenko 24 уровень
23 мая, 12:13
Разобрался. Надо было делать createComment при каждой вставке, а я создал один коммент и пытался его вставлять.
Ответить
0
Ваня Жуков 40 уровень, Санкт-Петербург
24 апреля, 23:23
Не используйте темповый файл для парсинга.
Ответить
0
Yurs Volod 23 уровень, Минск
1 марта, 15:38
Объясните, почему мы обязаны обертывать текст в CDATA, вместо того чтобы просто заменить символы "<" ">" и прочие на "& lt;" "& gt;" и так далее? В условии же сказано что xml МОЖЕТ содержать  CDATA и в этом случае комментарий не проставляется.
Ответить
0
Вадим Власов 39 уровень
14 марта, 23:33
видимо потому что это зарезервированные символы и заменять их нету смысла, они все равно будут так же представляться... а с CDATA мы их видимо экранируем
Ответить
0
Inna Lapina 40 уровень, Львов
23 февраля, 01:16
Мда, задача из серии пойми, что от тебя хотят, сам это нагугли, изучи все и напиши всякое разное. Помогли вот эти статьи и комментарии, конечно.
Document для обработки входящего текста и Transformer для обработки результата создаем аналогично как тут написано:
Начало работы с XML в Java
Создаем список всех нодов и обновляем их, если есть CDATA , я брала метод без рекурсии.
Перебрать все ноды
При наличие тега у нода, добавляем комментарий.

Ответить
+4
Artem Murk 35 уровень, Днепр
22 января, 15:48
Вот именно та задаче, которая засталяет все гуглить с нуля(кроме JAXB). Ну что ж в поисках нужных методов пришлось полностью пройтись по методам разбора XML. Если не хотите как я потеть над поиском решений то вот стек используемых классов и теххнологий :JAXB, DOM, Transformer. 
Мои ддействия более подробно:
1)  При помощи JAXB сериализовал документ.
2) Создал рекурсивный метод для обхода nodeList (гугл в помощь). В нем
    а) Каждую ноду проверял на имя Тега Если имя подходило  - создавал коментарий и пихал перед 
        данной нодой.
    б) Каждую текстовую ноду проверял на CDATA символы, соответсвенно если они были, то заменял данный текст на CDATA текст.
3) С помощью трансформера (и прописанными Проперти) трансформировал мой документ в строку.
Ответить
+2
Парьев Дмитрий 40 уровень, Нижний Новгород
14 января, 04:19
Можно сделать и без Document и тому подобное.
1. obj -> xml
2. создаем список строк
3. в первой строке в конце меняем "yes" на "no" (хз зачем нужно, но без этого никак!)
Далее со второй строки:
4. если в начале строки нужный тег, то добавляем строку перед с комментарием (столько же пробелов в начале, чтобы выдержать стилистику)
5. берем текст между тегами, если он есть
6. если текст содержит символы (экранирующие символы) & или < или > или '  или ", то заключаем текст в тег "<![CDATA" не забываем закрывающий "]]>".
Когда прошлись по всем строчкам, далее:
7. соединяем все в строку.
8. заменяем символы & и < и > на & и < и > соответственно.
9. проверяем на двойное вхождение "<![CDATA[<![CDATA[" (такое может быть, предыдущий алгоритм, тег CDATA обернет еще раз в такой же тег) соответственно закрывающий от него будет два раза.
10. return
Все задача решена.
Ответить
+1
Парьев Дмитрий 40 уровень, Нижний Новгород
14 января, 04:26
пункты с 4 по 8:
(в 17-20 строках в matches и replaceAll без пробелов)

String reg = "<" + tagName;
String coment = "<!--" + comment + "-->\n";
for (int i = 1; i < list.size(); i++) {
     String ss = list.get(i);

     int f = ss.indexOf(reg);
     if (f >= 0) {
         sb.append(ss.substring(0, f)).append(coment);
      }

      int n = ss.indexOf(">");
      int k = ss.lastIndexOf("<");
      String sd = "";
      if (k > n) sd = ss.substring(n + 1, k);

      if (!sd.equals("")) {
          if (sd.matches((".*(& amp;|& lt;|& gt;|'|\").*"))) {
              sd = sd.replaceAll("& amp;", "&");
              sd = sd.replaceAll("& lt;", "<");
              sd = sd.replaceAll("& gt;", ">");
              sd = "<![CDATA[" + sd + "]]>";
              ss = ss.substring(0, n + 1) + sd + ss.substring(k);
           }
       }
       sb.append(ss).append("\n");
  }

Ответить
0
Вадим Власов 39 уровень
14 марта, 23:35
лучше разобраться как работает XML парсер, а не городить как на начальных уровнях
Ответить
0
Парьев Дмитрий 40 уровень, Нижний Новгород
16 марта, 11:12
Мне кажется нет такого понятия начального уровня и другого, есть язык и его возможности.
Нужно делать так, чтобы работало.
Если простыми методами решение более читабельно, стабильно и оптимизировано, зачем городить иное?
Можно использовать тяжеловесные структуры и потратить кучу ресурсов и времени, а результат будет такой же.
Ответить
+1
Парьев Дмитрий 40 уровень, Нижний Новгород
16 марта, 11:55
Для кого как, в общем..
Было бы интересно, протестировать наши решения на потребление ресурсов и скорость исполнения)
Ответить
0
Вадим Власов 39 уровень
16 марта, 12:02
вы же, надеюсь, не пишите каждый раз заново допустим класс Map только из за того, что возможно он недостаточно быстро работает?
Ответить
0
Парьев Дмитрий 40 уровень, Нижний Новгород
16 марта, 12:39
Я же не говорю что XML парсер не нужен, для серьезной работы необходим.
Но все зависит от конкретной задачи. Будет необходима скорость, буду писать или использовать что-то другое.
Я надеюсь вы же не будете писать рекурсию, чтобы посчитать d+d+d+....+d, вместо for, потому что рекурсии нет на начальных уровнях?)
Ответить
0
Вадим 40 уровень
2 января, 20:29
Если б не комменты - долго бы голову ломал. Игорю отдельная благодарочка по этому поводу.
Вообще конечно понятия не имею откуда я должен был догадаться о существовании классов Document, Node, NodeList и Transformer... И тем более о том, как ими правильно пользоваться. Понятно, что когда знаешь куда копать уже StackOverflow поможет, но вот если вовсе не знаешь... В общем бредовая немного задача, можно было бы и объяснений немного в условие приложить. Хотя бы намекнуть на вектор копания этих ваших интернетов.
Ответить
+2
Парьев Дмитрий 40 уровень, Нижний Новгород
14 января, 04:33
Можно и без этих классов сделать, главное условие понять.
А оно мутное, без пол литра никак.
Ответить
0
Zed 40 уровень, Новосибирск
23 ноября 2017, 05:49
Написал решение при помощи декоратора на XMLStreamWriter + учет CDATA, валидатор с 28.11.17 принимает :)
Ответить
0
Ната Винокурова 38 уровень, Брянск
31 октября 2017, 19:43

Метод toXmlWithComment не должен изменять входящий xml в случае, если искомый тег отсутствует в нём.



Вранье! CDATA должен быть проставлен в любом случае во всех тегах, где есть соответствующие символы в текстовом узле.
Ответить
+2
Андрей Пушкин 36 уровень
22 декабря 2017, 14:26
Ната, спасибо! Вот специально ведь писал 

if(документНеСодержитВхожденийИскомогоТэга) {
return документБезИзменений;
}


И не проходил...
Ответить
0
Дмитрий Шалухов 35 уровень, Минск
20 октября 2017, 22:34
Забыл standalone и encoding выставить - 6 попыток, пока разобрался. С одной стороны, понимаю создателей валидатора. С другой стороны в стоимость курса уже должен быть включен литр валерианки...
Ответить
0
Санёк Ростовцев 26 уровень
13 октября 2017, 10:31
Я так и не понял, что нужно Валли. ttps://javarush.ru/help/780
Ответить
0
Санёк Ростовцев 26 уровень
13 октября 2017, 10:34
Решил сразу после того как коммент опубликовал!!! :)))) Во прикол!!!
Ответить
0
Игорь 40 уровень, Москва
14 сентября 2017, 13:51
Я знаком с DOM моделью, уже занимался подобным на JavaScript и Python. Разработчики не пытаются заставить работать с XML как с текстом, поэтому крайне рекомендуется пользоваться специальными инструментами:
Document, NodeList, Node, Transformer.
Тем не менее, условие задачи сформулировано не однозначно. В итоге, как я понял, сделать нужно следующее:
1. Сериализовать объект в строку, представленную в XML формате.
2. Вставить комментарий перед нужным тегом.
3. Если в текстовом узле есть экранирующие символы, то заменить его на CDATA.
Ответить
+11
Игорь 40 уровень, Москва
14 сентября 2017, 13:51
Алгоритм:
1. Конвертируем объект не в строку, а в объект Document.
2. Итерируем по каждому узлу документа.
3. Если имя узла совпадает с нужным, вставляем перед ним узел с комментарием.
4. Если первый потомок узла является текстовым узлом, то делаем в нем проверку на наличие экранирующих символов:

"
'
<
>
&


5. Если находим, достаем содержимое текстового узла, заменяем текстовый узел на CDATA, вставляем в новый узел сохраненное содержимое.
6. Конвертируем документ в строку (вот это было совершенно не очевидно, пришлось знакомиться с Transformer).
Ответить
+12
Игорь 40 уровень, Москва
14 сентября 2017, 13:56
Для тестирования можно воспользоваться следующими классами:

@XmlRootElement(name = "first")
public class First {
    @XmlElement(name = "second")
    public String item1 = "some string";
    @XmlElement(name = "second")
    public String item2 = "need CDATA because of <second>";
    @XmlElement(name = "second")
    public String item3 = "";
    @XmlElement(name = "third")
    public String item4;
    @XmlElement(name = "forth")
    public Second[] third = new Second[]{new Second()};
    @XmlElement(name = "fifth")
    public String item5 = "need CDATA because of \"";
}

public class Second {
    @XmlElement(name = "second")
    public String item1 = "some string";
    @XmlElement(name = "second")
    public String item2 = "need CDATA because of <second>";
}

Ответить
+16
Игорь 40 уровень, Москва
14 сентября 2017, 13:56
Запускаем так:

public static void main(String[] args) throws JAXBException, ParserConfigurationException, TransformerException {
    System.out.println(Solution.toXmlWithComment(new First(), "second", "it's a comment"));
}

Ответить
+9
Игорь 40 уровень, Москва
14 сентября 2017, 13:59
Результат:

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<first>
    <!--it's a comment-->
    <second>some string</second>
    <!--it's a comment-->
    <second><![CDATA[need CDATA because of <second>]]></second>
    <!--it's a comment-->
    <second/>
    <forth>
        <!--it's a comment-->
        <second>some string</second>
        <!--it's a comment-->
        <second><![CDATA[need CDATA because of <second>]]></second>
    </forth>
    <fifth><![CDATA[need CDATA because of "]]></fifth>
</first>

Ответить
+8
l1s 26 уровень, Санкт-Петербург
29 октября 2017, 14:07
Условие было несколько невнятным. Прочитав алгоритм, который вы указали, въехал в суть. Задача решена, спасибо за комментарии.
Ответить
+1
Славиша Мишич 40 уровень
19 ноября 2017, 22:01
Следующий фрагмент делает то что надо:
if (currentNode.getTextContent().matches(".*[<>&'\"].*")) {...}
Ответить
+1
Vitaly Kurnosenko 24 уровень
24 мая, 13:44
Спасибо, поправил свою регулярку, после этого валидатор принял. До этого задача не проходила по п.п 3, 5.
Ответить
0
shooter_2134 36 уровень
29 августа 2017, 23:00
кто недавно решил и не затруднит маякнуть в лс?
Ответить
0
Алексей Белоусов 38 уровень, Tikhvin
24 августа 2017, 11:07
Задача на изучение org.w3c.dom
Ответить
0
Artem Novikov 40 уровень, Харьков
15 августа 2017, 11:13
Это раз http://info.javarush.ru/JavaRush_tasks_discussion/2015/01/15/level33-lesson10-bonus01.html#comment43166
Условие как всегда не полное, а финальное решение на мой взгляд не соответствует условию и требованию валидатора.
Судя по ветке, все плюс минус основной функционал делают правильно. Но потом остаются момент для танцев с бубнами. Кто захочет сэкономить пару суток времени - пишите в личку.
Ответить
0
Roman_UA 41 уровень, Киев
20 июня 2017, 20:01
Еще добавлю момент, который меня каждый раз смущал при отправке на проверку - наличие тестовых класов в классе Солюшн и тестового кода в методе мейн - на проверку это НЕ ВЛИЯЕТ!
Ответить
0
Roman_UA 41 уровень, Киев
20 июня 2017, 16:16
Кто решил, помогите плз - http://help.javarush.ru/questions/184557/com-javarush-task-task33-task3309-%D0%BD%D0%B5-%D0%BF%D1%80%D0%BE%D1%85%D0%BE%D0%B4%D0%B8%D1%82-%D0%BF%D1%80%D0%BE%D0%B2%D0%B5%D1%80%D0%BA%D1%83-2-%D0%BF%D1%83%D0%BD%D0%BA%D1%82%D0%B0
Ответить
+1
MaxLich 40 уровень, Санкт-Петербург
4 июня 2017, 17:10
Решил задачу. Помогла ссылка с хелпа, которую тут кинули. Ещё вот хороший ресурс http://khpi-iip.mipk.kharkiv.edu/library/extent/prog/iipXML/x-udom.html , тоже помог разобраться во всём этом. Задача оказалась довольно простой.
Ответить
+6
MURS 35 уровень, Киев
18 июня 2017, 14:29
Тут, видать, уже все, что могли потереть, кроме самых умных комментариев, потерли. Киньте, пожалуйста, ссылочку)
Ответить
0
MaxLich 40 уровень, Санкт-Петербург
20 июня 2017, 18:58
Если это вопрос ко мне, то у меня же в комменте есть ссылка на то, как работать с деревом DOM
Ответить
0
MaxLich 40 уровень, Санкт-Петербург
20 июня 2017, 19:05
А если вопрос был по поводу темы на хелпе, но она там легко ищется, называется "хинты и подсказки" (подозреваю, что ты её прочитал, но всё равно не смог сделать).
Ответить
0
Roman_UA 41 уровень, Киев
20 июня 2017, 19:57
Спасибо, с твоим советом (методом) прошел задачу! В хелпе все отметил. (В ЛС не могу написать - лимит исчерпан)
Ответить
0
Vitya 33 уровень, Нижний Новгород
2 июля 2017, 17:41
Thanks!
Ответить
0
Alexey Malakhov 37 уровень, Москва
10 августа 2017, 13:19
Привет! Кинь пожалуйста эту ссылочку.
Ответить
0
Максим Хоменко 36 уровень
11 апреля 2017, 21:17
зарезервированные xml символы - так называемые сущности & ' " < >  
Я вначале не выделял текстовые узлы их содержащие в CDATA, думал, что  CDATA встречается уже в самом текстовом значении каких-либо строковых свойств объекта, допускал, также что в строковых свойствах могут быть целые фрагменты XML, поэтому заодно попрактиковался в осуществлении вставки XML фрагментов вместо этих текстовых узлов.. но это оказалось это не нужным и не принялось валидатором абсолютно.
Ответить
0
Максим Хоменко 36 уровень
11 апреля 2017, 19:49
Фишка в том, что нужно самим заключать в CDATA те текстовые узлы которые содержат пять зарезервированных символов. Об этом в условии почему-то не сказано, но имеется в виду.
