
Ааа блин, а ведь можно было решить такую задачу за 5 минут, с помощью ScriptEngineManager.
Но нет, хотят велосипед.
И я таки буду сейчас этот велосипед писать, как-бы "для общего развития".
P.S. Сам я написал только регулярку для подсчета количества операций, остальное - "допил" чужого решения.
Ответить
0
Slana 24 уровень, Москва
позавчера, 11:06
Возможно, кому-то поможет:
Не проходила валидацию, вопрос был не в ошибке программы, а исключительно в формате вывода. И вновь - вопрос к формулировкам в условии.
Валидацию прошла, как только сменила
System.out.println(roundDouble(Double.parseDouble(expr),2)+" "+countOperation);
на 
 NumberFormat nf = new DecimalFormat("#.##");
            Double d = Double.parseDouble(expr);
           System.out.println(String.format("%s %d", nf.format(d),countOperation));
Вот кто-нибудь может объяснить, где из условия следует, что первый вариант вывода некорректен?
roundDouble(Double.parseDouble(expr),2) - метод, округляющий double до 2х знаков после запятой.
Ответить
0
Евгений Власов 34 уровень, Москва
пятница, 12:02
Ура!!! 392!
Вот такую штуку пришлось сделать при выводе.
format.setDecimalSeparatorAlwaysShown(false);
Ответить
0
Алексей Бутузов 27 уровень
20 июня, 18:14
удивительное условие:
4. Метод recursion должен быть рекурсивным.
при этом в программе
public void recursion 

void, Карл!
зачем методу вызвать себя рекурсивно, если результат вызова не будет получен, т.к. тип метода  void?
Ответить
0
Мистер Исключительный 40 уровень
6 июня, 08:40
378й
Где-то 100 строчек с регулярками и лямбдами.
thx Inna Lapina за ссылку с тестами.
Ответить
0
Marina 35 уровень, Санкт-Петербург
9 мая, 20:15
И я 359я :)
просто отметиться :)
Ответить
0
Николай Соколов 31 уровень
3 апреля, 07:52
#350
Вот и настало моё время отписаться =))
Делал без фанатизма, но из-за моей тупости, пришлось потратить неделю на решение. Из 350 решивших, я самый тупой. Осознание того, что эту задачу решило уже 350 человек очень мотивирует. Не хочется оказаться хуже всех. Код очень уродливый, корректировать не было настроения, особенно после того, как он прошел все тесты. (ссылки на тесты есть в комментах)
1. Тем, кто не знает, с чего начать, советую решить что-то простое. Например (2*3*5*10 ).
2. Я первым делом убрал из выражения все пробелы, что всем советую - тогда не придется их обрабатывать.
3. В выражении находим самые внутренние скобки, решаем все что в скобках, затем раскрываем их.
4. Читаем обсуждение http://info.javarush.ru/JavaRush_tasks_discussion/2015/01/13/level34-lesson02-home01.html - все вопросы уже давно решены.
5. result = new BigDecimal(result).setScale(4, RoundingMode.HALF_UP).doubleValue(); округляем до 4-го знака промежуточные результаты или не пройдет тест : "0.000025+0.000012", без этого в результате будет число типа 1.234e-10.
6. https://www.freeformatter.com/java-regex-tester.html#ad-output  ссылка на тестер регулярных выражений с готовыми примерами. Например: if (resultString.matches("^[-+]?\\d*\\.{0,1}\\d+$")) {} проверит, является ли переданная строка resultString числом double со знаком + или -. Если "да" , то можно раскрыть скобки...
Пока решал, напрочь забыл, что такое jason и все что было раньше на этом уровне =))
 Спасибо всем решившим за полезные комментарии!!!
Ответить
0
Сергей 40 уровень
30 марта, 20:00
Сделал!
Всего эту задачу решили 348 учеников. 
Конечно перечитал коменты, плюс большой набор проверок.
Решение получилось не совсем красивое, хотелось бы взглянуть не "эталонное".
Ответить
0
Johann 40 уровень
16 марта, 15:48
Задача однозначно стоит того чтобы ее решить. Номер 338, 5 попыток и запрос помощи. Почувствовал себя ортопедом - хирургом. 270 строк, из них половина - костыли, подпорки и швабры. Уже  по ходу решения пришло осознание, что решать лучше с помощью очереди в части скобок ну и давно пора начинать знакомиться с TDD . 
Пара дополнительных проверочных выражений, которых не было ранее, криво написал метод расчета геометрии, вот в них и уперся, добавляйте к существующим:

s = "cos(2*(-5+1.5*4)+28)-sin(2*(-5+1.5*4)+28)";
        System.out.print(s + " expected output 0.37 13  actually ");
        solution.recursion(s, 0);
        s = "1^cos(0)";// вместо ^ может быть любой другой оператор, учитывайте
        System.out.print(s + " expected output 1 2  actually ");
        solution.recursion(s, 0);

Ответить
0
Тимур 40 уровень
4 марта, 21:11
УРА! 5 дней и я решил эту задачу! 12 попыток и я номер 329

Накодил просто ужасно, в 200 строк, это и то как-то отрефакторил, через 3 дня взгляну и не пойму что там написано))

парочка напутствий для тех кто в недоумении от этой задачи:
1) Она стоит того что бы решить ее,
2) Переменные можно объявлять внутри методов
3) Методов можно делать сколько угодно
4) countOperation = количеству знаков (*, /, ^, +, -, cos, sin, tan) в мат.выражении
5) regexЫ очень помогли, даже не знаю как без них бы решил
6) Соблюдайте приоритеты знаков, сначала (), затем sin, cos, tan, затем ^ и т. д.

И да,  ссылка на проверки от Inna Lapina очень помогла.
Ответить
+1
Inna Lapina 40 уровень, Львов
28 февраля, 16:40
Вдруг еще кому-то будет полезно.

Новый набор выражений для проверки https://javarush.ru/help/1302
На старом наборе с info.javarush, который все используют, у меня было все отлично. А на этом сразу стало видно, что такие ситуации, как например 2^(-2) или  2^-2, у меня неправильно обрабатывались. 

Валидатор для этой задачи дебильный, для гораздо более простых задач он дает массу детальной информации, что работает не так, а в этой задаче фиг поймешь, что не работает, и что ему не нравится в выводе. И с чего метод recursion внезапно для него не рекурсивный, хотя я даже в один этот метод все решение запихнула, и уж точно он рекурсивно запускает сам себя тыщу раз.
Ответить
+2
Андрей Пушкин 36 уровень
5 февраля, 15:35
Да, да, да, да!!!! Ура, я - номер 315! С отрицательными числами действительно пришлось помучаться. 
Конечно, стыдно за костыльный код, но радость победы пьянит, как разреженный воздух вершины Эвереста. P.S. Алгоритм от Вадима чуть ниже.
Ответить
0
Artem Murk 35 уровень, Днепр
29 января, 14:45
Ура, 311)) Сложная задачка, но вперемешку с предыдущими легкими нормально развивает мозг. Спасибо Вадиму за ссылочку на проверку данных, недочеты в своей программе исправлял в ней. 

Писал так же как и предыдущие коментаторы, множество регулярок. Небольшой лайфхак для решающих. Операции считаются все, если стоит минус перед числом, например -1 - то это тоже считается операцией(что крайне меня удивило). Обошел данную проблему передавая константу операций. В начале  рекурсии считал все знаки(выставил условие если счетчик операций == 0) операций, а потом передавал данное число вглубь рекурсии, не изменяя. 
Ответить
+2
koderman 40 уровень, Алматы
28 января, 16:58
фух решил, 310 - й)
очень помог материал по ссылкам ниже, для теста. Понаписал только 242 строки кода. хз много или норм)
Ответить
0
Парьев Дмитрий 40 уровень, Нижний Новгород
19 января, 12:35
Хорошая задача. Условия, что нельзя добавлять ни полей, ни методов, и сигнатуру нельзя менять у рекурсии, заставили изощряться. И код вырос в десять раз.
Делал через регулярки.
Метод:
0. Подсчет количества операций. Если ноль то коунт ставим в -1.
И всегда по рекурсии передаем это число, до самого конца.
1. выделил внутренние скобки (если есть)
2. проверил число ли там (да, то раскрыть)
3. если нет, то выполнить операцию по старшинству (sin cos tan ^ / * + )
операции минус нет! Так как минус тот же самый плюс, но с отрицательным числом))
4. заменить в формуле выражение (из п.3) на результат округленный до 2 чисел после запятой.
5. рекурсия(формула, коунт).
6. return обязательно, ибо мы все сделали на этом шаге и ничего больше выполнять не надо.
7. когда доходим до конца метода, значит у нас окончательный результат его и выводим.
Если коунт -1 то выводим 0.
Ответить
0
Моряк Папай 40 уровень
26 января, 18:50
Методы можно добавлять, че
Ответить
0
Парьев Дмитрий 40 уровень, Нижний Новгород
30 января, 14:40
Ну отлично. Сам себе усложнил значит.
Ответить
0
Андрей Пушкин 36 уровень
9 января, 13:00
Вот для тех, кто считает эту задачу не жизненной. Собеседование в Яндекс, практическая часть. Задача практически такая же, правда немного шире - операций больше. Читайте, кто реально хочет стать программистом. Хабр, Яндекс-собес :)
Ответить
+1
Вадим 40 уровень
7 января, 20:13
Поначалу даже не хотел браться за задачу - понимал что гемор еще тот. Но решил и не жалею - хоть по своей практической значимости и бесполезная, зато неплохо подтянулось понимание рекурсии, и, что пожалуй еще важнее, регулярных выражений, классов Pattern и Matcher. Всё руки не доходили)
Для тех, кто как и я поначалу не знает с какого боку подступиться к этой задаче, вот мой вариант основного алгоритма:
1. Выделить выражение в самых внутренних скобках.
2. Выделить из этого выражения единичную операцию по приоритету: sin cos tan >> ^ >> / * >> + -
3. Посчитать операцию.
4. Заменить выражение результатом выполнения операции (в первоначальном выражении).
5. recursion(измененноеВыражение, countOperations + 1).
6. return; - чтобы программа не шла дальше, иначе каша будет и в голове и в аутпуте)

Конечно, будет еще куча нюансов, связанных со скобками, отрицательными числами и прочей ерундой, но то уже при дебаге разобраться можно.
Лично я попарился над проблемой подсчета операций отрицания числа (не минус, а именно отрицание, "-2" например - это 1 операция). В итоге всё решилось довольно просто - к отрицательным числам приписал 0 и считал как обыкновенное вычитание ("0-2").

В общем, дерзайте, тигры! Задача того стоит! ;)

P.S.: полезные ссылки, которые мне очень помогли:
1. Тестовые выражения
2. Для проверки созданных регулярок
Ответить
+4
Евгений 40 уровень
7 января, 14:14
решил сам, вообще все возможные варианты выражений работают правильно, но вали не принял((((
пришлось идти на гитхаб...((((
Ответить
0
Максим (upsarin) 40 уровень
31 декабря 2017, 10:18
Для меня оказалась самой интересной задачей за последние 33 уровня.
Очень помогли тесты http://info.javarush.ru/JavaRush_tasks_discussion/2015/01/13/level34-lesson02-home01.html#comment50848

Для тех, кто не знает, как подойти к задаче - попробуйте сначала обработать простой случай - когда всего один оператор. А дальше добавляется разбиение на такие простые случаи и рекурсия в конце.

Решал без использования BigInteger, использовал Double + DecimalFormat("#.#######") для промежуточных вычислений и DecimalFormat("#.##") для итога.

Количество операций можно посчитать сразу при первом входе в процедуру.

297 решило.
Ответить
0
Гравицапа 40 уровень
19 декабря 2017, 19:28
Всего эту задачу решили 294 учеников. Негусто...
Но задача интересная. Пока решал нашел несколько вариантов решения.
Ответить
0
Алексей Белоусов 38 уровень, Tikhvin
17 декабря 2017, 19:04
Задача конечно сложная, но решение есть. Я округлял каждое действие и не принимало, убрал округление возведение в степень и приняло!
Наример: 2+8*(9/4-1.5)^(1+1)
округляя каждое действие выходит 6.48 6
Не округляя возведение в степень 6.5 6

Считал количество действий 1 раз(!) Что странно потому что нужно просто посчитать количество символов (+ - * / ^) и тригонометрических операций(sin, cos и tan).
Ответить
+1
dimskiy 28 уровень, Санкт-Петербург
18 декабря 2017, 13:36
Может, вы сможете хотя бы намекнуть как сделать рекурсию void-метода? Как из него вызвать его же самого и принять какие-то результаты??
Ответить
0
askir 40 уровень
18 декабря 2017, 14:35
Т.е. у вас на каждой итерации были выражения типа 0.0871557427476581658698506771543179638683795928955078125*cos(10)+5.333333333333333333333333333333333 ?
А округляли в конце при выводе?
Ответить
0
askir 40 уровень
18 декабря 2017, 14:52
Я делаю на каждом шаге одно вычисление и передаю измененное выражение на следующий шаг, пока не останется число:
sin (2*(-5+1.5*4)+28)
sin(2*(-5+6.0)+28)
sin(2*(1.0)+28)
sin(2.0+28)
sin(30.0)
0.499999999999999944488848768742172978818416595458984375
Ответ:
0.5 6
Но непонятно почему не принимает
Ответить
0
dimskiy 28 уровень, Санкт-Петербург
18 декабря 2017, 17:04
Так может потому что они в выводе хотят видеть только последнюю строку? У меня затык именно в том как передавать рекурсивные результаты вышестоящей копии метода... Даже уже экспериментирую с переопределением System.out :(
Ответить
0
askir 40 уровень
18 декабря 2017, 17:22
Вот это:
sin (2*(-5+1.5*4)+28) 
sin(2*(-5+6.0)+28) 
sin(2*(1.0)+28) 
sin(2.0+28) 
sin(30.0) 
0.499999999999999944488848768742172978818416595458984375
- это параметры для рекурсивных вызовов
а вывод я делаю только тогда, когда в expression передается число

По адресу https://javarush.ru/help/1302 нашел большой список проверок, думаю пригодится
Ответить
0
Алексей Белоусов 38 уровень, Tikhvin
18 декабря 2017, 19:42
recursion(final String expression, int countOperation)
{
,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,
,,,,,,,,,,,,,,,,,,,,
recursion(newExpression, countOperation)
return;
}
Замечу, что подсчет операций делается при первом вызове метода
не знаю баг или фича, но приняло
параметры "-5" 0 выхлоп -5 1
параметры "5" 0 выхлоп 5 0  
Ответить
0
Алексей Белоусов 38 уровень, Tikhvin
18 декабря 2017, 19:46
Округлял после каждого вычисления. 2 раза не приняло, но когда убрал округление после возведения в степень, то прошло. Ответ тоже округлял.
Короче, просто война с валидатором.
Ответить
0
askir 40 уровень
18 декабря 2017, 23:33
"параметры "-5" 0 выхлоп -5 1 
параметры "5" 0 выхлоп 5 0 "
Это правильно, так как в первом случае есть операция отрицания
Ответить
0
askir 40 уровень
18 декабря 2017, 23:34
Округляли этим - .setScale(2, RoundingMode.HALF_UP)?
Ответить
0
askir 40 уровень
19 декабря 2017, 14:50
я взял эту задачу !!!!
Нужно читать обсуждение http://info.javarush.ru/JavaRush_tasks_discussion/2015/01/13/level34-lesson02-home01.html

Еще мне помогла замена в вычислении степени с

BigDecimal v = new BigDecimal(param1).pow(new BigDecimal(param2).intValue(), MathContext.DECIMAL32);
String value = v.setScale(4, RoundingMode.HALF_UP).toString();

на

Double v = Math.pow(Double.parseDouble(param1), Double.parseDouble(param2));
String value = decimalFormat.format(v);


Ответить
+2
Алексей Белоусов 38 уровень, Tikhvin
19 декабря 2017, 16:38
Ага, тоже там черпал информацию, очень помогли тесты.
Ответить
0
Гравицапа 40 уровень
19 декабря 2017, 19:03
dimskiy, тут рекурсия работает наоборот. Вышестоящему ничего передавать не надо. И вышестоящие ничего на экран не должны выводить (можно сделать просто return после рекурсии). Здесь нужно наоборот передавать измененное выражение нижестоящему. Самый нижний должен выдать результат.
Ответить
0
dimskiy 28 уровень, Санкт-Петербург
20 декабря 2017, 13:46
Спасибо, попробую!
Ответить
0
Igor Minin 34 уровень, Санкт-Петербург
4 декабря 2017, 17:41
Дамы и господа, скиньте, пожалуйста, решение этой задачи, которое принял валидатор. Для меня задача свелась к поиску валидного решения :) Даже не стал заморачиваться, и даже не совестно.
Ответить
0
Андрей Кондрашов 40 уровень, Казань
11 декабря 2017, 14:30
dmitryshds
Sapienti sat
Ответить
0
Igor Minin 34 уровень, Санкт-Петербург
18 декабря 2017, 17:26
merci
После обновления номера задач изменились, и по task... были только не валидные решения.
Ответить
0
Vladimir Komarov 28 уровень, Волгоград
13 ноября 2017, 13:40
Задача - дичь полная.  Даже для обучения непригодна, не то, что в реальной жизни.
Придете вы на работу, спросят что умеешь - разбирать скобки - До свиданья!
Задача скорее на регулярные выражения нежели Коллекции, которые пытаемся пройти.
Ответить
0
Дмитрий Шелемех 36 уровень, Москва
15 ноября 2017, 14:42
ну я на регулярках сделал.. все равно не проходит валидатора. хотя все примеры решаются :(
Ответить
0
Ro Do 40 уровень, Киев
17 ноября 2017, 16:35
Твоему терпению и усидчивости можно позавидовать
Ответить
0
Karahanid 40 уровень, Алматы
13 ноября 2017, 12:52
Жесть какая-то. Пропускаю. Я слишком туп для этого.
Ответить
+1
Ната Винокурова 38 уровень, Брянск
5 ноября 2017, 18:48
Нужно ли делать проверку на валидность вычисляемого примера?
Ответить
0
Kroll 36 уровень, Владивосток
19 октября 2017, 14:03
Задача - жесть. Жырнющяя вышла. Тянет на большую задачу в конце уровня. У ней не правильное название написали, следовало назвать "парсер математических формул".
Ответить
0
Владимир Панов 40 уровень, Харьков
15 октября 2017, 03:48
ну или нашли решение))
Ответить
0
Владимир Панов 40 уровень, Харьков
15 октября 2017, 03:47
а решение есть, 258 человек уже решили
Ответить
0
Another Life 40 уровень, Санкт-Петербург
14 октября 2017, 23:25
из той же серии, что и большая задача "ресторан" - хоть своей головой, хоть с гитхаба - ни одно решение не принимает. Печалька(
Ответить
0
Виктор Павлович 40 уровень, Москва
27 сентября 2017, 23:47
дичь какая-то...впервые прям в недоумении сижу...
если хотите сдать задачу, ищите её на гитхабе.
а вот если хотите РЕШИТЬ задачу, то вряд ли вы её сдадите
Ответить
0
Александр Шаповалов 35 уровень, Санкт-Петербург
19 сентября 2017, 09:16
Перепробовал миллион вариантов - не работает.
Пожалуйста напишите в лс, хочу посмотреть рабочий код, сдать эту задачу, могу прислать мой вариант.
Ответить
0
Дмитрий Почепцов 40 уровень, Санкт-Петербург
12 сентября 2017, 11:04
Все еще не одолел валидатор. По второму условию не хочет проходить ни как. И чего ему собаке нужно?  И округляю после каждого действия и два знака на выводе рублю.  Примеры все какие нашел отрабатывает верно. Что делать?
Ответить
0
Славиша Мишич 40 уровень
3 декабря 2017, 21:51
Используй:
new BigDecimal(result).setScale(2, RoundingMode.HALF_UP)
Ответить
0
Дмитрий Почепцов 40 уровень, Санкт-Петербург
5 сентября 2017, 13:21
Буду благодарен за верную ссылку.
Ответить
0
Anonymous #1121181 36 уровень, Москва
13 августа 2017, 01:43
как это решать. вообще ноль идей
Ответить
0
Sergey Krava 40 уровень, Маунтин-Вью
7 августа 2017, 12:15
Если есть ссылка, скиньте и мне
Ответить
0
MURS 35 уровень, Киев
19 июня 2017, 21:21
Спасибо гитхабу
Ответить
+1
Yermek 40 уровень, Алматы
20 июня 2017, 18:33
поделитесь ссылкой пожалуйста! :)
Ответить
0
Anonymous #1100255 35 уровень, Москва
22 июня 2017, 13:15
и со мной пожалуйста тоже поделитесь )
Ответить
0
Иван Филинчук 40 уровень, Харьков
22 июня 2017, 16:50
list.add("me");  =)
Ответить
0
Domadin 36 уровень
13 июня 2017, 23:28
Жесть задачки пошли...
Ответить
0
Kavalevich A 40 уровень
10 июня 2017, 02:06
Спасибо phob !
