
такие задачи заставляют тебя чувствовать себя гавном)
Ответить
0
Денис Кайдунов 36 уровень, Гомель
9 июля, 23:51
если у кого будет писать что не соответствует количество слов - последний пункт. то попробуйте пооборачивать в try и отлавить ошибку.. мне помогло не ожиданно. и ... Я ЭТО СДЕЛАЛ!!!! САМ!!!! СУПЕР!
Ответить
0
Вадим Чубаров 24 уровень
5 июля, 15:59
Решил не строить из себя профи , запилил 600+ строк универсального говнокода и в конце волшебный костыль и валидатор повержен )

если кому будет полезно :
помимо того что указано в условии 
- нужно предусмотреть случай когда несколько одинаковых (или разных)слов могут быть в одной строке + часть из них в прямой а часть в обратной последовательности 
- метод должен употреблять без проблем массив любого размера 
Ответить
0
Ярослав 24 уровень
3 июля, 21:15
Скорее всего оставлю эту задачу на будущее ...
Ответить
+1
Oleg Solovichenko 25 уровень, Екатеринбург
26 июня, 20:01
Писал бы валидатор подробнее о том что ему не нравится...  написал, вроде все находит, проверял не только те два слова но и по остальным линиям, валидацию не прошел( Писали бы на каких словах они тестят. В итоге кончилось терпение на второй вечер и просто скомуниздил код
Ответить
0
Oleg Solovichenko 25 уровень, Екатеринбург
28 июня, 18:20
По другому переписал, но уже не могу проверить валидатором.
Если кто захочет у меня скопипастить прошу написать проходит валидацию или нет
https://github.com/rymbil/JavaRush/blob/master/JavaCore/task2027/Solution.java
Ответить
0
Maksim 23 уровень, Самара
16 июня, 01:40
Жирновато получилось)
1)Два вложенных цикла
2)Проверяем в какую сторону помещается искомое слово по 8 направлениям. И в этом случае не надо бояться выхода за границы массива.
3)Ну и дальше в цикле сравниваем по буквам.
GitHub

Ответить
+1
Егор 26 уровень, Екатеринбург
8 июня, 19:18
На первый взгляд просто адовая задачка. Думал, что решать буду дня два. На самом деле все оказалось просто:

1. делаем два вложенных цикла прохода по матрице (x, y)
2. для каждого искомого слова
3. если первая буква слова совпадает с элементом матрицы (x, y)
3.1. продолжаем поиск по 8 векторам (в цикле)
3.2. в цикле от 1 до длины искомого слова
3.2.1. если следующая буква не совпадает с элементом массива (x, y) + вектор, то завершаем цикл, слово не найдено
3.2.2. если цикл закончен и не словили исключение (выход за границу матрицы) - слово найдено 

исходный код на гитхаб
Ответить
0
Егор 26 уровень, Екатеринбург
14 июня, 12:02
AbstractMap это абстрактный класс от которого унаследованы Map-ы: HashMap и т.д. 
AbstractMap.SimpleEntry был использован чтобы метод мог вернуть пару значений сразу. 
Ответить
0
Артем 26 уровень, Минск
14 июня, 15:17
То есть это, по сути, обычная карта без прикрас?)
Типа "не знаю, какая карта надо, возьму абстрактную родительскую"
Ответить
0
Егор 26 уровень, Екатеринбург
14 июня, 15:27
Нет, AbstractMap это абстрактный класс, т.е. нельзя создать его объект или экземпляр. А экземпляр AbstractMap.SimpleEntry можно, потому что он не абстрактный.
Ответить
0
Артем 26 уровень, Минск
14 июня, 16:13
А в данном случае какой смысл именно в этом классе, а не в обычном хэшмэпе, например
Ответить
0
Максим 25 уровень, Москва
1 мая, 22:39
Решил сам.
А с самого начала расширил матрицу со всех сторон на длину самого длинного слова, встречающегося в параметрах, чтобы не натыкаться на выход за пределы массива, как в предыдущем задании :)
Да, много вложенных циклов - в одном, самом глубоком месте  - 5 циклов for в глубину. Но метод detectAllWords вышел в 39 строк плюс в начале класса статическая переменная:
static final int[][] directions = {{1, 0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};
Да, было трудно удержать в голове, что сейчас обрабатывается - нанизывается буква, перебирается направление, перебираются искомые слова или идёт проход по матрице букв, но всё получилось :) 
Ответить
0
Сергей 28 уровень, Москва
21 мая, 00:35
Приятно встретить тут единомышленников ))
Пару дней размышлял, тоже допер до того что надо обернуть исходную матрицу в границы из нулей, чтоб не выходить за границы матрицы.
Ну а принцип такой, что находя первую букву слова, смотрел вокруг нее все совпадения со второй буквой и записывал массив возможных смещений, их может быть несколько. Потом брал поочередно каждое смещение и шагал в этом направлении собирая слово, если в итоге слово смогло собраться - писал его в искомый массив с координатами. В качестве направления создал класс Pair<Integer, Integer>(пара полей и геттеры). Чтоб не городить сильно вложений цикл, сделал отдельно метод, который возвращал мне ArrayList<Pair<Integer, Integer>>
32 строки основной метод + 15 строчек вспомогательный метод
Ответить
0
Егор 26 уровень, Екатеринбург
8 июня, 19:26
зачем городить еще одну матрицу, когда есть try... catch?
Ответить
+3
Komers 21 уровень
21 июня, 21:45
тсс, здесь же люди учатся)
Ответить
0
Егор 26 уровень, Екатеринбург
22 июня, 07:56
И что? Если не задавать неудобные вопросы они от этого лучше учиться станут?)
Ответить
0
Komers 21 уровень
23 июня, 12:00
Проехали. Я тоже использовал try, чтобы не городить ерунды
Ответить
0
Денис Кайдунов 36 уровень, Гомель
9 июля, 16:34
Жесть, это же надо такое было придумать!!!)))) Ржу не могу!!!))
try{}cath(ArrayIndexOutOfBoundsException exc)
Ответить
+2
Daos 27 уровень
7 апреля, 22:48
Решил на этой задаче разобраться с рекурсией, в итоге все влезло в примерно 20-25 строчек.
Решение
Подозреваю, что все равно перемудрил, если есть идеи как переписать findLast - пишите в личку.
Ответить
+3
Daniel 32 уровень
3 апреля, 19:38
В общем наговнокодил я знатно, зато мой вариант:
- умеет находить слова не только на прямой линии, и при этом учитывает чтобы при поиске слова одна и та же буква не была использована дважды.
- записывает в слова весь путь, а не только индексы первой и последней буквы в матрице.
- позволяет задавать в каких направлениях искать слова, а в каких нет.

Зачем я всё это сделал? Я не хотел делать сто вложенных циклов и начал решать задачу через графы и тут понеслась. Мой вариант можно посмотреть тут. Задача крутая.
Ответить
0
Юрий Кузнецов 35 уровень
25 апреля, 12:16
Ты чего??? с ума сошел?))) вот это кодиЩе
Ответить
+1
Егор 26 уровень, Екатеринбург
8 июня, 19:24
очень много кода, очень много :)
Ответить
0
Дмитрий Дедков 28 уровень
7 марта, 05:16
небольшое дополнение: нужно найти не просто первое попавшееся слово, а все варианты данного слова в кроссворде.
Ещё можно дописать конструктор у класса Word.
Первая буква просто ищется, потом вторая вокруг неё + при нахождении задаётся вектор поиска, по которому ищутся остальные буквы. Что-то типа обхода графа в глубину.

с циклами fori примерно 50 строк кода ушло

Задача класс!
Ответить
0
Евгений Дмитриев 22 уровень, Екатеринбург
24 февраля, 20:03
На заметку тем, у кого не проходит проверку.
Сначала создал в программе внутренний статический класс , чтобы код был более читаемым, вывод программы был правильный, но валидатор упорно не принимал решение...Сделал тот же код в одном методе, валидатор принял.
Ответить
0
Jola 40 уровень, Львов
9 февраля, 03:53
код вписался в 230 строк......наговнакодила конечно, но хотелось основательно разобраться с задачей.
Прошлась по всем 8 направлениях в массиве по отдельности, начальные и конечные координаты слов устанавливала только после проверки equals найденного слова и слова, передаваемого в аргументе функции. Потратила весь день, но зато довольная.
Ответить
0
Жоский Тип 31 уровень, Москва
12 декабря 2017, 13:47
Сразу увидел два вектора решения: очевидный с поиском опорных точек и ограничениями, лобовой-топорный с проходом по всем строкам/диагоналям в поисках слов. Реализовал в итоге второй, т.к. по-моему, для огромных матриц, решение более оптимальное, т.к. не нужно каждый раз пробегать весь кроссворд для поиска новой опорной точки.

Решение свелось к 4м большим циклам и массиву вида byte[3][crossword[i].length]. Тупо по строчкам пишем каждый символ в батах в первую стркоу массива, а х и у координаты во вторую и третью. Получаем для каждой строки массив байт, где у каждого символа есть координата. Из первой строки берем строку String line=new String(gg[0]); - важно, что бы массив был byte (что бы строка собралась) и при сохранении в него привести int к byte :

gg[0][j]=(byte)crossword[i][j];
                    gg[1][j]=(byte)i;
                    gg[2][j]=(byte)j;

ну а потом изи-пизи:

for(String w:words) {
if(line.contains(w)){
                    Word word=new Word(w);
                    word.setStartPoint(gg[2][line.indexOf(w)], gg[1][line.indexOf(w)]);
                    word.setEndPoint(gg[2][line.indexOf(w)+w.length()-1], gg[1][line.indexOf(w)+w.length()-1]);
                    result.add(word);}
                if(new StringBuilder(line).reverse().toString().contains(w)){
                    String reversed=new StringBuilder(line).reverse().toString();
                    Word word=new Word(w);
                    word.setStartPoint(gg[2][reversed.length()-1-reversed.indexOf(w)], gg[1][reversed.indexOf(w)]);
                    word.setEndPoint(gg[2][reversed.length()-reversed.indexOf(w)-w.length()],gg[1][reversed.length()-reversed.indexOf(w)-w.length()+1]);
                    result.add(word);
                }
}


ну найти координаты и начала и конца изич, если они под каждой буквой записаны)
нереально горд собой, 1 попытка, bitch!
Ответить
+1
Дмитрий 31 уровень
3 декабря 2017, 22:31
Поставил задачу, решить своими силами, решил.  Хоть и много кода, но все пашет, знаю, где сократить, знаю как улучшить, но пока, и этому радуюсь, больше всего строк в моём коде занимает создание объекта Word, а сама логика  поиска слова в ту или иную сторону, всего 4 строчки
Ответить
0
Александр Масловский 34 уровень, Волгоград
26 ноября 2017, 14:42
Решил не то, чтобы даже с первой попытки, но и с первой компиляции, что на меня непохоже совсем. Даже сначала не поверил и решил вывести результат на экран, чтобы проверить себя.
Код занял меньше 60 строк
Ответить
0
RMuskovets 30 уровень, Львов
19 января, 20:58
как это? у меня только по рядам 100 строк
Ответить
0
RMuskovets 30 уровень, Львов
20 января, 13:29
точнее 60
Ответить
0
Mr.Robot 24 уровень, Москва
24 ноября 2017, 00:17
Алгоритм решения понял сразу же - аналогия с предыдущим заданием налицо: ищем опорную точку (первую букву) и от нее пляшем по "розе ветров". Очень муторно расписал условия для всех 8 направлений (где что отнимать, где что прибавлять + проверка выхода за границы массива) - почти все делается copy-paste с корректирующими исправлениями - просто нужно внимательно и осмысленно расставлять + и -. Фиг с ним - потратил времени на 2 серии Доктора Рихтера. С первого же запуска - верный ответ. А дальше ... началась сага "чего хочет от меня этот ... валидатор". Сделал чтобы искало несколько вариантов расположения одного и того же слова, сделал - чтобы только один вариант для каждого слова, сделал, чтобы искало слова из одной буквы и чтобы только один экземпляр слова из одной буквы... Прочитал все предыдущие комментарии - учел... Короче, надоело "перекрашивать забор" - взял готовое решение - оно полностью повторило вывод одного из моих предыдущих вариантов, но валидатору оно нравится... Я вот думаю, если я допустил принципиальную ошибку (исключения не учел или еще что), то ментор мог бы более прозрачно на это намекнуть, вместо того, чтобы давать дельное замечание, что в моем списке не совсем стока слов скока ему хотелось бы.
Ответить
+5
swen922 37 уровень
8 января, 01:26
Аналогичная фигня, грешил на точность поиска, но проканало с 4-ой попытки с небольшой перетасовкой: надо было все слова сразу добавить в список, а потом уже искать начала и концы..
Ответить
0
Ярослав 39 уровень, Днепр
20 января, 23:41
Жизненно.
Ответить
0
Сергей Ирюпин 24 уровень
15 ноября 2017, 11:21
Решил с первой попытки, создав "матрёшку" из 3х дополнительных методов:

private static int[] getEndXY(int[][] crossword, String word, int x, int y) // 6 строк
private static String getWord(int[][] crossword, int x, int y, int dx, int dy, int len) // 4 строки
private static char getChar(int[][] crossword, int x, int y) // 4 строки


Ну и сам public static List<Word> detectAllWords() 13 строк
Кому интересно - обращайтесь, покажу код ;)
Ответить
0
Artem Murk 35 уровень, Днепр
13 ноября 2017, 12:49
Всем привет) Решал сначала задачу с помощью гавнокода, дошел код до 250 строк(Еще не написанной программы!!). Мне данная ситуация вообще не понравилась, стал переписывать т.к. много повторяющегося кода (DRY). Всего вышло 120 строк кода, после того как нормально начал писать.

Итак: 
1)Проходил по массиву, искал нужную букву.
2) При нахождении правильной буквы создал метод в который кидаешь начальные данные и вектор поиска, а он выплевывет тебе слово(или ошибку) Ошибку ловил и ничего с ней не делал(программа перепрыгивала добавление ногово слова).

//один из примеров кода( входные данные: кроссворд, Слово которое ищем, коорд X первой буквы найденной в п1., координата У первой буквы найденной в п1, направление по Х, направление по У)
                        try{
                            allWords.add(checkWord(crossword, word,i,j,+1,0));
                        }catch (Exception e){}



 
Ответить
0
Artem Murk 35 уровень, Днепр
13 ноября 2017, 14:37
Уже решенная задача на ГитХабе
Ответить
+4
RMuskovets 30 уровень, Львов
19 января, 20:59
класс
Ответить
0
Zed 40 уровень, Новосибирск
10 ноября 2017, 09:39
Еее... строк много, зато более-менее красиво имхо :)
Написал поиски через рекурсию, по методу для каждого вида поиска (по горизонтали, обратно по горизонтали, по вертикали, обратно по вертикали и т.д.), пример одного из методов:

public static int[] findWordHor(int[][] crossword, char[] wordChars, int indexChar, int pointI, int pointJ) { //indexChar - на входе 0, point'ы - на входе координаты найденной первой буквы слова...

    if (pointI < crossword.length && indexChar < wordChars.length) {
        if (crossword[pointI][pointJ] == wordChars[indexChar]) {
            if (indexChar == wordChars.length - 1) return new int[]{pointI, pointJ};
            else return findWordHor(crossword, wordChars, indexChar + 1, pointI + 1, pointJ);
        }
    }

    return null;
}


В итоге, если найдены все подряд буквы слова, возвращаются координаты крайней и создается объект Word со всеми необходимыми данными :)
В detectAllWords перебор слов и для каждого по 2 вложенных цикла пробежки по массивам.
Ответить
0
Zed 40 уровень, Новосибирск
10 ноября 2017, 09:42
Короче только для тех, кто уже решил :)
Ответить
0
Евгений 40 уровень
7 ноября 2017, 21:05
Эх, сначала придумал решение, пока писал решение решило разрастись в все стороны, итого почти 250 строк(вся задача), валидатор принял.
Потом решил подумать и родилась идея сделать решение через String, и написал я решение в 70 строк, но валидатору оно не нравится, хотя вывод правильный и вообще со всех сторон это решение лучше, даже выглядит красиво...
Ответить
0
Евгений 40 уровень
7 ноября 2017, 21:35
обалдеть, прошел валидацию со вторым решением, добавив булеан переменную и её проверку в циклах, а после каждого найденного слова ставил ей значение фалсе. 
Видимо для валидатора важно, что бы как только слово найдено мы переходили к следующему.
Ответить
0
Парьев Дмитрий 40 уровень, Нижний Новгород
29 октября 2017, 22:02
Можно решить проверяя по букве через рекурсию. Почти поиск в глубину.
Остановка рекурсии:
1. если конец таблицы или не та буква, то слова нет
2. все слово найдено.
Можно слова даже змейкой находить поменяв пару строк кода.
Ответить
0
Вадим Власов 39 уровень
13 октября 2017, 22:28
Вам удалось ее решить с 26 попытки.- ну что... очень даже не плохо :)
секрет лишь в этих двух строчках в методе detectAllWords()

Solution.crossword = crossword;
List<Word>coordinats= new ArrayList<>(); 
Ответить
0
Vra 40 уровень
11 сентября 2017, 22:06
по-сложней предыдущей будет, пришлось повозиться, много мелких ошибок..
решил, валик не принимал, думал чудит, но все же 1 тест неверно выводил

как комментом ниже писали, setStartPoint лучше делать после нахождения конечной точки, иначе координаты неверно запишет

алгоритм следующий получился..
1 сразу в List<Word> list добавляю все слова

2 для каждого слова цикл: прохождение по массиву с поиском 1 буквы,
3 далее проверка на 8 направлений на поиск слова целиком
  4 по диагонали 4 в стороны с условиями
4 из List<Word> удаляю слова с координатами 0-0 0-0
код на 110-130 строчек сначала, но 8 циклов внутри (на проверку направлений) вынес в 1 метод, код сократится до 30, еще можно попробовать матрицу направлений вынести отдельно))

отличная задача, много условий приходилось держать в голове при написании..
пока решал несколько алгоритмов в голову пришло
интересно, можно ли рекурсией решить
Ответить
+1
LeoJames 40 уровень
1 октября 2017, 16:40
https://github.com/Data-Q7/JavaRush/blob/master/Part-2/Level-20/task10/12/Solution.java
Идея хорошая, только я немного подправил под свой стиль.
Не добавлял слова в отдельный массив, а просто считывал из аргументов.
Искал в 8 направлениях не целиком, а по 1 букве т.к. потеря ресурсов и времени.
Координаты изначальные ставил -1.
8 циклов, если мысль понял правильно, изменил на 1 цикл где к начальным координатам точки прибавлял направление (т.к. x+(-y) тоже самое что и (x - y)), а выход за границы убрал блоком исключений.
И, да, матрицу вынес отдельно.
Ответить
0
Александр Зыков 21 уровень
31 августа 2017, 14:13
написал решение в 50 строк  - тест прошел, валик не принял.
спустя три попытки и 5 часов прошел валидацию с решением в 110 строк.
Попался на ошибках:
- setStartPoint экземпляра Word надо делать только После нахождения второго хвоста слова.
- надо бы  обрабатывать односимвольные слова.
- в большом количестве вложенных for и if оператор break нифига не информативен и без использования метки "до куда отменять" возникают проблемы с пониманием что происходит.
Прозрачнее стало когда разбил код на методы. Но вышли те самые 110 строк(((

Ответить
+1
nicotinko 22 уровень
25 августа 2017, 23:06
Хорошая задача. Решать я её конечно не буду) Пока) Не терпится следующий квест начать)
Ответить
0
Anonymous #1068415 31 уровень, Воронеж
31 июля 2017, 11:48
Хорошая задача. Решение реально оказалось уложить в ~30 строк даже в одном методе. Обилие вложенных циклов и условий в одном методе (~8 вложенных друг в друга for и if!) разрывает мозг, поэтому я бы советовал тем, кто будет решать, подумать о том, чтобы разбить код на 2 (или даже 3?) метода: скажем, detectAllWords ищет совпадение первой буквы для каждого слова из words, вызывает второй метод и возвращает результат, а второй метод, скажем, testWord пытается от переданной буквы записать слово по всем направлениям и добавляет в list проинициализированный объект Word.
Ответить
0
Pavel Reshetilo 33 уровень, Днепр
18 сентября 2017, 21:07
начал делать вложенными ифами и мне это очень непонравилось. До горя дурацкий и не читаемый код получился.
Я вынес в переменные направления просмотра слов
int[] x = new int[]{1, -1, 0, 0, 1, 1, -1, -1};
int[] y = new int[]{0, 0, 1, -1, 1, -1, 1, -1};
и потом в цикле просто прогнал варианты поиска слов в разных направлениях. 

Сам детект вордс занял 25 строк. 
и отдельный метод, который по переданным координатам и направлениям собирает слова - 20 строк. 
Ответить
+2
Stupid007 40 уровень
1 июля 2017, 19:16
поясните 4 пункт условия, а то что-то я не улавливаю о чем оно. Именно условие, а не требование.
Ответить
0
Александр Колинченко 40 уровень, Москва
28 июля 2017, 23:18
Я понимаю так, что валидатор будет проверять на заведомо присутствующих в crossword словах. Т.е. не обязательно добавлять проверки, есть ли вообще такое слово, не надо отрабатывать list = null и т. д. 
Ответить
0
Вадим 40 уровень
25 июня 2017, 18:46
Отличная задача на развитие алгоритмического мышления. Было приятно повозиться с ней, а потом приятно увидеть что она работает)
Ответить
0
Александр 27 уровень, Москва
19 июня 2017, 22:52
18 строк detectAllWords и 16 строк findWord, который ищет слово по кругу вокруг точки принимая направление по X и Y
Соответственно вынес в массив все возможные направления и перебираю их пока не найду нужное слово, потом перестаю его искать(это важно). Если вы находите несколько одинаковых слов по одному запросу, задачу не зачтут
Ответить
+1
Pavel Reshetilo 33 уровень, Днепр
18 сентября 2017, 21:12
зачли. 
У меня перебирает все варианты вокруг найденной буквы
Ответить
0
Александр 35 уровень
17 июня 2017, 22:40
Решал с векторами, или как их тут называют. С первого раза, метод detectAllWords поместился в 32 строки.
Ответить
0
Дмитрий Шалухов 35 уровень, Минск
21 мая 2017, 13:54
Задача шикарная. В качестве подсказки. Заведите массив множителей направления. Тогда код вообще становится простым (массив множетелей [смещение по x;смещение по y], допустим вниз влево будет [-1;-1]). Весь рабочий код вместился в 46 строк (включая пустые).
Ответить
0
Алексей Бородин 24 уровень
13 мая 2017, 13:50
Очень помогла проверка detectAllWords(crossword, "home", "same", "poe")
Я решал через создание векторов. Сначала мапил весь массив, составляя мапу ArrayList-ов для каждой буквы, затем создавал вектор с началом, который соответствовал точке первой и последней буквы. Затем пришлось вектор валидировать, т.к. в нашем crossword есть 'p' и 'e' отстоящие друг от друга на равном расстоянии. Пришлось проверять букву по середине, чтобы убедиться, что я правильный вектор выбрал

Да, проверял detectAllWords(crossword, "jr", "rr", "oe", "mm", "vo", "jrgs", "vorg", "aaa") на принятом валидатором коде, результат такой:
[jr - (4, 4) - (4, 3), rr - (3, 2) - (3, 3), oe - (5, 1) - (4, 1), vo - (5, 2) - (5, 1), jrgs - (4, 4) - (1, 1), vorg - (5, 2) - (2, 2)]

Так что не надо возвращать те слова, которые не были найдены в кроссворде
Ответить
0
Donatello 32 уровень
8 октября 2017, 23:26
Мой код возвращал то же самое + повторно искал другие варианты найти то же слово.
Убрал такую возможность - решение совпало с вашим.
Однако валидацию, тем не менее, так и не проходит. 
Ответить
0
Igor Minin 34 уровень, Санкт-Петербург
11 мая 2017, 12:18
Хорошая задача, голову приходится поломать знатно, чтобы учесть все варианты.
Ответить
+1
Beslan Bavizhev 37 уровень
29 апреля 2017, 23:40
Не обязательно добавлять в список все повторяющиеся слова. Я добавлял только первые найденные и валидатор принял.

for (Word word : detectAllWords(crossword, "jr", "rr", "oe", "mm", "vo", "jrgs", "vorg", "aaa")) {
     System.out.println(word);
}

Результат:
jr - (4, 4) - (4, 3)
rr - (3, 2) - (3, 3)
oe - (5, 1) - (4, 1)
vo - (5, 2) - (5, 1)
jrgs - (4, 4) - (1, 1)
vorg - (5, 2) - (2, 2)
Ответить
0
Roman_UA 41 уровень, Киев
25 апреля 2017, 15:49
На каноничность не претендую, но я проходил все 8 направлений путем перебора шагов для i и j в единственном двойном цикле for меняя значения шагов в диапазонах от -1 до 1.
Ответить
0
Domadin 36 уровень
24 апреля 2017, 15:39
Переписал задачку по след. алгоритму (150 строк кода получилось)
1. Берем слово, выцепляем из него 1 букву.
2. Начинаем поиск по массиву, если находим совпадение...
3. Проходимся от найденной 1 буквы в каждом направлении (всего 8) с проверкой, влезет ли наше слово по данному направлению (не выйдет ли за рамки, вызвав исключение ArrayOutOfBound)
4. Составляем для каждого прошедшего проверку направления строим слово тут же сравниваем его с исходным словом. Если совпадает...
5. Создаем новое слово (слова, если найдено больше 1 совпадения) и вносим его(их) в массив. Продолжаем поиски по массиву.
Ответить
0
Alexey Malakhov 37 уровень, Москва
30 апреля 2017, 18:11
А как делал проверку по диагоналям ?
Ответить
0
victor 30 уровень, Минск
10 мая 2017, 23:08
сделал аналогичный алгоритм. пока не оптимизировал его, но валидация не проходится. пишет: time out. Даже незнаю, что трогать, чтобы она не посыпалась. Но как говорится, лучше хоть какая нибудь, но рабочая) оставлю оптимизацию на будущее, наверное.
Ответить
0
Domadin 36 уровень
12 мая 2017, 09:55
Alexey, при помощи StringBuinder-a побуквенно составлял слово, передвигаясь в сторону нужной диагонали, а потом сравнивал его с базовым словом. Допустим, вверх-вправо у меня по оси y--, а по оси x++, потому что при движении вверх порядковый номер массива уменьшается, а при движении вправо порядковый номер элемента в массиве увеличивается. 
Ответить
0
Vladimir Mikhaylov 37 уровень, Санкт-Петербург
15 мая 2017, 14:48
Есть гениальное решение по такому-же алгоритму в 30 строк (не мое). https://gist.github.com/FaAway/5b0acbceb883796678dd
проходит на ура
Ответить
+2
Lesha 40 уровень, Минск
18 мая 2017, 19:39
Писал аналогичны алгоритм, отрабатывает хорошо, но валидацию не проходит.. и занял он у меня меньше 100 строчек.
Ответить
0
Danila 36 уровень, Москва
8 июля 2017, 13:49
спс за ссылку, мой код почти 200 строк, осталось только обратиться в индийское посольство за гражданством(
Ответить
+4
Domadin 36 уровень
23 апреля 2017, 13:35
Код получился, конечно, ужасный. Больше 300 строчек с копипастом. Кто-нибудь может скинуть ссылку с каноничным решением данной задачи в ЛС? Жаль, конечно, что после того, как решишь, нет примера решений от админов.
У кого не проходит.
Учтите, что, из одной и той же буквы может выходить несколько слов.
Добавляю свои тесты дополительно (обратите внимание на rr и oe)
System.out.println(detectAllWords(crossword, "jr", "rr", "oe", "mm", "vo", "jrgs", "vorg", "aaa"));
[jr - (4, 4) - (4, 3), jr - (4, 4) - (3, 3), jr - (5, 4) - (4, 3), rr - (3, 2) - (3, 3), rr - (3, 2) - (4, 3), rr - (3, 3) - (3, 2), rr - (3, 3) - (4, 3), rr - (4, 3) - (3, 3), rr - (4, 3) - (3, 2), oe - (5, 1) - (4, 1), oe - (4, 2) - (4, 1), oe - (1, 4) - (2, 4), vo - (5, 2) - (5, 1), vo - (5, 2) - (4, 2), jrgs - (4, 4) - (1, 1), vorg - (5, 2) - (2, 2), aaa - (0, 0) - (0, 0)]
Ответить
0
Domadin 36 уровень
12 мая 2017, 09:47
Ниже писали, что если слова нет, его нужно выводить с нулевыми координатами. У меня таким образом прошло, но я не смог протестировать, верно так ли это необходимо для валидатора.
Ответить
0
Pavel Reshetilo 33 уровень, Днепр
18 сентября 2017, 21:17
я не выводил, если слово не найдено. Да и в условии сказано, что слово полюбому есть
Ответить
0
Антон Вайбс 28 уровень, Москва
17 апреля 2017, 21:38
Обратите внимание на проверочный пример, он корректен:
Ожидаемый результат
home - (5, 3) - (2, 0)
same - (1, 1) - (4, 1)

У вас должно получиться тоже самое для этих слов.

если у нас массив в привычной записи - a[i][j]
то в setStartPoint и setEndPoint
первым параметром передаем j и вторым i а не наоборот!
Ответить
0
Ринат 28 уровень, Уфа
3 апреля 2017, 16:19
\* Комментарий удален модератором \*
Ответить
0
Ната Винокурова 38 уровень, Брянск
9 апреля 2017, 16:09
У меня результат совпадает, но не пропускает. Видимо, дело не в поиске всех вхождений слова.
Ответить
0
Yevgeniy 25 уровень
14 апреля 2017, 13:49
Я не знал, что в кроссворде слова могут повторяться :)
Я учитывал, что слово может быть только один раз в массиве и может вообще не быть. Если слова нет в массиве, то оно тоже выводилось, вот так, Home - (0, 0) - (0, 0)
Валидатор решение принял
Ответить
+1
Дмитрий 27 уровень, Одесса
21 апреля 2017, 15:57
Присоединяюсь, решение проходит все тесты какие предлагались в комментариях, но валидатор не пускает
Ответить
0
Beslan Bavizhev 37 уровень
29 апреля 2017, 23:26
Я добавлял в лист только одно вхождение слова и валидатор принял.
Ответить
0
Кирилл Кириллов 32 уровень, Екатеринбург
2 апреля 2017, 07:37
я тут такого нагородил за два дня, отрабатвыает строки предложенные astronah-ом и предложенные Валерием Требух... тестирование не проходит. Также учел что вдруг если слова нету в списке то всеравно добавляю в список с нолями
Ответить
0
Andrey Gromov 30 уровень
10 февраля 2017, 15:09
Кто решил задачу?
В новой версии плагина выдает ошибку, что размер списка слов не соответствует ожиданиям. 
Админы, сюда вообще можно выкладывать код программы для обсуждения?
Ответить
0
Bazz 29 уровень
2 апреля 2017, 08:58
выкладывай, админов тут не бывает
Ответить
0
Зепп Бранниган 40 уровень
15 мая 2017, 14:31
Кхе-кхе...
Ответить
+6
Danila 36 уровень, Москва
8 июля 2017, 13:48
ха-ха-ха
