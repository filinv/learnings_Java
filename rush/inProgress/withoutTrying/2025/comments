 Олег 22 уровень
18 июля, 07:45
Сделал задачу и со статическими переменными и с кучей методов разных. Прикрутил рекурсию - которую сам додумал. Сам допер до использования массива для сложения уже вычисленных значений степеней.
Хотя конечно идею по которой происходит сужение проверяемого множества пришлось посмотреть. Понятно было что повторения смотреть не нужно, но описать даже словами лаконично это не получалось.
Один рабочий день потрачен.
Ответить
0
Ігор Миколайчук 28 уровень
16 июля, 12:36
круто
Ответить
0
Dmitry Ryabov 22 уровень, Москва
8 июля, 12:14
Подсказки для тех, кто будет решать:
1) Под натуральными числами имеются числа строго больше 0, т.е. 1,2.3....
2) В задача нельзя использовать статические переменные в классе. Дурацкое условие, о котором нигде в задаче не написано. Всё должно происходить внутри метода getNumbers.
3) Полученный массив должен состоять из чисел строго меньше N.

Полезные ссылки сюда кидали.

P.S. Лучше решать задачу самому, а не рефакторить код из ссылки. Тогда получите непередаваемые эмоции. Потратил 4 дня на задачу и ощутил что значит оптимизация и анализирование поставленной задачи со всех сторон.

P.S.S. Разработчикам задачи. Указывайте в задаче условия более подробно. На догадках тратятся лишние попытки и это не круто. За задачу огромное спасибо.
Ответить
0
Моряк Папай 40 уровень
10 июля, 08:42
Статические переменные можно использовать сколько угодно. Главное чтобы твой метод getNumbers() можно было нормально использовать. А если он возвращает правильный результат только при первом вызове - согласись, это не совсем правильно.

public static void main(String[] args) {
    System.out.println(Arrays.toString(getNumbers(1000)));
    System.out.println(Arrays.toString(getNumbers(100)));
}

Ответить
0
Dmitry Ryabov 22 уровень, Москва
11 июля, 06:22
Согласен на все 100.  Почему-то эта мысль не приходила мне в голову. Век живи, век учись = )
Ответить
+2
Викторчег 27 уровень, Москва
4 июля, 19:27
Адовая задача с точки зрения борьбы с валидатором.
Написал решение с генерацией в соответствии вот с этим алгоритмом:
https://acmp.ru/article.asp?id_text=198
при Long.MAX_VALUE все отрабатывало в заданные рамки (время и память), при этом валидатор не пропускал.

Ок, написал второй вариант решения, который использует предгенерированные значения в массиве и сравнил с выдачей первого решения на диапазоне от 0 до Long.MAX_VALUE - всё идентично.

Второй топорный вариант валидатор пропустил, первый же нет.

Это больше похоже на какое-то издевательство, хотя бы писали тест на котором валидатор не пропускает, иначе это все сводится к поиску иголки в стоге сена с уймой зря убитого времени.
Ответить
0
Rodriguez 23 уровень, Киев
10 июля, 03:18
"в соответствии вот с этим алгоритмом:
https://acmp.ru/article.asp?id_text=198"

Я, наверное,чего-то не понял.
Объясните пожалуйста,как в соответствии с этим алгоритмом найти,например, число 370?
Число с такой же степенной суммой , удовлетворяющее условию "любая цифра не меньше предыдущей и не больше последующей" будет 037

И что означает "а потом лишь убедиться в том что число 153 - это число Армстронга."? Имеется в виду,убедиться, что оно попадает в диапазон от 1 до N?
Ответить
0
Викторчег 27 уровень, Москва
10 июля, 16:33
Отвечая на ваш вопрос:
число 037 не входит в анализируемые, поскольку мы рассматриваем натуральные числа и начинаем анализ с 0,1,2..., 10, 11, 12 ... 20, 22 ... 30, 33, 34 ... 36, 37

>>> И что означает "а потом лишь убедиться в том что число 153 - это число Армстронга."
У чисел 135, 153, 315, 351, 531 и 513 одинаковая степенная сумма и она равна 153, поскольку сами числа представляют из себя комбинации одинаковых цифр.

Поскольку мы уменьшаем количество вариаций для анализа ради ускорения программы мы из указанного набора числен анализируем только число 135, поскольку ищем те, у которых каждое последующее число больше или равно предыдущему.

Мы берем число 135, получаем степенную сумму 153.

А поскольку мы ищем числа, равные их степенной сумме, мы берем получившуюся степенную сумму от 135 равную 153 и получаем её степенную сумму. 

Смотрим что полученная сумма равна исходному числу и сохраняем.

Мы проводим манипуляцию с получением степенной суммы от степенной суммы, поскольку это более универсальный механизм. Можно его рассматривать как аналог поиска получившейся суммы в последовательности возможных перестановок цифр числа 135 = {153, 315, 351, 531 и 513}. Если число есть в этой последовательности, то это наше число, если нет, идем дальше.

Ответить
0
Rodriguez 23 уровень, Киев
10 июля, 21:16
Допустим у нас диапазон от 1 до 500.
Мы двигаемся с 1 вверх, допустим дошли до 123
1<=2<=3 - подходит.
Тогда вычисляем степенную сумму - это 36.
Какие наши дальнейшие действия?


И с числом 370 все же непонятно, как представить его в соответствии с предложенным алгоритмом, чтобы его составляющие каждое предыдущее было <= последующему?
Ответить
0
Викторчег 27 уровень, Москва
11 июля, 13:07
Берем число 36 и проверяем является ли оно числом армстронга:
1) получаем его степенную сумму, она равна 45
2) сравниваем её с числом 36, 45 != 36, значит это не число армстронга

Насчет числа 370 - про нули тоже не стоит забывать.

Вы посмотрите на это со стороны того, как будете эти числа перебирать:
1) сначала получаете порядок конечного числа (количество цифр в нем)
2) начинаете рекурсивно эти числа генерировать в цикле уменьшая порядок на единицу и плюсуя с произведениям чисел с десяткой в степени нужного порядка

Вот пример анализируемых чисел на больших порядках:
66890
66899
66900
66990
66999
67000
67700
67770
67777
67778
67779
67780
67788
67789
67790
67799
Ответить
0
Rodriguez 23 уровень, Киев
11 июля, 21:04
Надо разбираться. Наверное, позже еще вернусь к этой теме.
Спасибо за ответы!
Ответить
0
Олег 22 уровень
17 июля, 18:33
Всё правильно говоришь. Будешь рассматривать 0_3_7. чтобы найти число 370.
Ответить
0
Ярослав 24 уровень
3 июля, 15:56
Валидацию прошел, но решил ли я эту задачу ?
Нет, конечно.
Я только подогнал готовый алгоритм под валидатор ...
Ответить
+1
Airat 24 уровень, Уфа
22 июня, 11:02
Задача просто Адовая, решил только на третий день.
Обращаю внимание, что не должно быть статических переменных !!! (с ними все считает, но валик не пропустит!)

Ответить
0
Max Miheev 28 уровень, Москва
21 июня, 18:25
ЖЕСТЬ !!! решил с помощью гугления!  где найти инфу о числах Армстронга ?
Ответить
+1
Дмитрий 21 уровень, Москва
10 июня, 16:15
Я написал код на основе кода для поиска всех чисел Армстронга от однозначных до N-значных
https://github.com/shamily/ArmstrongNumbers

Мне понятно, как и зачем мы создаем матрицу степеней.
Мне понятно, что для чисел 135, 153, 315, 351, 513, 531 сумма 3-степеней чисел 1, 3 и 5 одинакова (153).
Мне понятно, что мы создаем два массива int[10], один для числа, второй для суммы, при этом для числа 9474 и числа 4497 digitsMultiSet[4] == 2,  digitsMultiSet[9] и [7] == 1, остальные == 0.
Дальше мы ищем, например, 4-значные числа с одинаковыми digitsMultiSet
Только для таких чисел мы считаем сумму.

Но мне не вполне понятна логика рекурсивного кода.
Ответить
0
Иван Мастеров 26 уровень
27 мая, 18:39
Самый быстрый и самый ресурсосберегающий метод решения данной задачи следующий:
1. создаем массив и вбиваем туда ответ для значения N = Long.MAX_VALUE. Например, long[] temp = {1, 2, 3, 4, 5, 6, 7, 8, 9, 153, 370, 371, 407, 1634, 8208, 9474, 54748, 92727, 93084, 548834, 1741725, 4210818, 9800817, 9926315, 24678050, 24678051, 88593477, 146511208, 472335975, 534494836, 912985153, 4679307774L, 32164049650L, 32164049651L, 40028394225L, 42678290603L, 44708635679L, 49388550606L, 82693916578L, 94204591914L, 28116440335967L, 4338281769391370L, 4338281769391371L, 21897142587612075L, 35641594208964132L, 35875699062250035L, 1517841543307505039L, 3289582984443187032L, 4498128791164624869L, 4929273885928088826L} (результат скопипастил из комментариев ниже);
2. в массив result забиваем только те значения, которые меньше значения N.

Можете не благодарить.
Ответить
+4
Evgeniy JK 30 уровень
2 июня, 19:07
Здравствуйте, сделал как вы посоветовали. Проверил с long.MAX_VALUE. Не проходит. Не подскажете, в чем дело? 
Ответить
0
Иван Мастеров 26 уровень
8 июня, 23:36
Вы мне в личку свой код сбросьте - я гляну.
Ответить
0
Anton Stezhkin 21 уровень
25 июня, 23:05
XD 
Ответить
0
Rodriguez 23 уровень, Киев
10 июля, 03:40
В итоге так и сделал.
Ответить
0
Сергей 28 уровень, Москва
17 мая, 23:16
Задачка не для слабонервных. Сдался под конец второго дня.
Сам допер до заготовленного массива с возведенными степенями, и метода сравнения для поиска разряда числа, а вот поиск вариаций составляющих сумму уже не асилил.
Подскажите, пожалуйста, толковую книгу по алгоритмам. Начал читать Сейджвик "Алгоритмы на Java"
Ответить
0
Ваня Жуков 40 уровень, Санкт-Петербург
12 мая, 15:12
Для тех кто не хочет брать готовое решение с ГитХаба, но не знает как оптимизировать решение методом грубой силы:
https://acmp.ru/article.asp?id_text=198

Для тех кто вычисляет степень через Math.pow():
http://qaru.site/questions/108003/wrong-result-by-java-mathpow
Ответить
+3
Aleksandr Pivovarov 28 уровень, Киев
28 марта, 11:33
Алгоритм Армстронга рулит. Без него моя задача выполнялась очень долго.

Еще нужно указать, что main не участвует в тестировании, а то я долго искал ошибку там.

Вы решили задачу лучше, чем 55% учеников. 
Вам удалось ее решить с 2 попытки. 
Среднее количество попыток для этой задачи 4.8. 
Всего эту задачу решили 3792 учеников.
Ответить
+2
GAZ 26 уровень
15 марта, 12:31
Использовал алгоритм ArmstrongNumbersMultiSetLongOpt
перекидал в результирующий массив функции getNumbers только те цифры которые меньше N.

Все равно ругается:
В массиве возвращаемом методом getNumbers не хватает элементов или есть лишние.


В чем может быть проблема? 
Может кто встречался?
Ответить
0
GAZ 26 уровень
19 марта, 10:12
Нужно избавится от статических переменных
Ответить
+1
Dmitry Ryabov 22 уровень, Москва
7 июля, 23:13
вот это самое дурацкое условие, о котором вообще нигде не написано. Лютый хейт за это разработчикам задачи.
Ответить
0
cron 31 уровень
7 марта, 15:44
Не так их и много самовлюбленных чисел, чтобы велосипед придумывать и скорость терять на вычислениях каждого.
Ответить
0
Knastnt 27 уровень, Санкт-Петербург
6 марта, 10:57
Подниму вопрос:
Сорри за тупой вопрос (судя по всему это тут для всех очевидно), но где вы смотрите время выполнения программы и использованную память?
Ответить
+2
Airat 24 уровень, Уфа
22 июня, 11:07
вот насчет памяти хз
Ответить
0
cyprusScorpion 37 уровень
2 марта, 13:56
Три дня битвы закончились, наконец:
"Задача успешно прошла тестирование!  Вы решили задачу лучше, чем 0% учеников. Вам удалось ее решить с 64 попытки. Среднее количество попыток для этой задачи 4.8. Всего эту задачу решили 3760 учеников".
Хитрость в том, что с помощью отдельно созданного от Solution класса ArmstrongNumbersMultiSetLongOpt и его метода generate() генерировать
следует все числа Армстронга вплоть до максимального: Long.MAX_VALUE.
Я генерировал до заданного числа N(long) по разрядности, затем отсеивал те, что были больше или равны N.
Хотя в обоих случаях результат выводится совершенно одинаковый, валидатор посчитал этот момент принципиально важным.

Если есть такие, кто решил эту задачу самостоятельно, не заглядывая сюда, в обсуждение, и в Google, им особый респект.

Даю ссылку на код класса ArmstrongNumbersMultiSetLongOpt, может кому пригодится:

https://github.com/biblelamp/JavaExercises/blob/master/Experiments/ArmstrongNumbersMultiSetLongOpt.java
Ответить
+4
Руслан Сафаргалеев 30 уровень, Уфа
15 февраля, 09:33
Задача на поиск Числа Армстронга до заданного числа N 
Решено с помощь алгоритма ArmstrongNumbersMultiSetLong.
Но у меня остается ВОПРОС:
Либо цель задачи была - нагуглить, разобраться,  дописать и вуаля. (Часто даже при работе необходимо)
Либо составить алгоритм самостоятельно!
Если первое - то я сделал все правильно.
Если второе, что мне кажется у многих тут, не хватит тех полученных знании, что бы это реализовать данный алгоритм с рекурсиями.
Ответить
+3
Моряк Папай 40 уровень
2 марта, 13:03
Думаю, многие смогут пойти по первому пути. А некоторым будет интересно самим составить алгоритм.
Ответить
0
Руслан Сафаргалеев 30 уровень, Уфа
2 марта, 17:58
Какой путь был правильным?
Ответить
0
Моряк Папай 40 уровень
2 марта, 18:08
Оба правильны. Зависит от человека.
Ответить
+3
Daos 27 уровень
5 марта, 23:17
Для меня это задача выглядит так:
- написать решение в лоб - удивиться как долго оно работает
- подумать и написать получше - получить терпимое время (2,5 мин)
- a что будет если разбить на потоки? - чуть быстрее
- а если поиграться с количеством потоков?
и так далее...
ну а когда надоест - скопировать решение с инета и забрать честно заработанную материю 
Ответить
+4
Airat 24 уровень, Уфа
22 июня, 11:17
Интересно, я вот до потоков не дошел, без них решил.
И вообще не понимаю нафига они здесь, чем помогут?
Ответить
0
Daos 27 уровень
22 июня, 11:34
Мой алгоритм достаточно глупый - нужно провести много одинаковых операций. Выполняя линейно - работает одно ядро процессора, а остальные простаивают. Делим на потоки - загружаем все ядра, уменьшаем время работы.
Ответить
0
Артем Васильчук 40 уровень
30 января, 16:49
есть ли вообще решение, которое принимается ?
Ответить
0
Моряк Папай 40 уровень
30 января, 21:08
есть
Ответить
0
Моряк Папай 40 уровень
2 марта, 12:59
Попробуй запустить с:
Long.MIN_VALUE,
Long.MAX_VALUE,
0,
1,
отрицательными числами.
Ответить
+3
cyprusScorpion 37 уровень
2 марта, 14:41
Написал тебе, а потом кто-то подсказал в обсуждении, что вначале сформировал список из всех чисел Армстронга, а я составлял список до заданного числа N (long) по разрядности.  Вместо N я вложил в параметр Math.log10() значение: Long.MAX_VALUE, возвращаемый методом результат - в параметр метода generate() класса ArmstrongNumbersMultiSetLongOpt, и валидатор поднял лапки кверху, в смысле выдал приз.
Когда валидацию прошёл,  увидел твой ответ, начал тестировать, мой вариант отличается лишь тем, что при вводе N, равным 0, компилятор выдаёт: 

Exception in thread "main" java.lang.NegativeArraySizeException.
Ответить
0
Юрий Шейнгарт 32 уровень
28 января, 16:29
Ребят, я уже устал играться с валидатором, если кто может - скиньте решение или ссылку на решение которое принимается! Спасибо большое.
Ответить
+3
Alex Yedamenko 23 уровень
24 января, 19:10
Эта задача - настоящий вызов. Решаю уже несколько дней и не хочу идти дальше, пока не решу её без готовых алгоритмов или обмана валидатора. В процессе битвы изучил вещи, о которых раньше даже не слыхал. Написал решение: у меня на компе при поиске меньше Integer.MAX_VALUE вкладываюсь в лимиты, при проверке на сайте по памяти где-то на грани. Но валидатор выбрасывает:

В массиве возвращаемом методом getNumbers не хватает элементов или есть лишние. 

Кто-то знает в каком диапазоне проверяет валидатор?  В комментариях прочитал, что только до Integer.MAX_VALUE . Это так? Или предупреждение о нехватке элементов он пишет и при перерасходе памяти? 
Ответить
0
Alex Yedamenko 23 уровень
25 января, 02:59
В комментариях противоречивая информация, что на данный момент надо искать?
1) натуральные числа меньше N;
2) натуральные числа меньше или равные N;
3) натуральные числа меньшей разрядности, чем разрядность N;
4) натуральные числа меньшей или равной разрядности, чем разрядность N;
Ответить
0
Моряк Папай 40 уровень
30 января, 21:08
В данный момент условия актуальны. Т.е. меньше N. Также указан тип N, соотв. отталкивайся от этого.
Ответить
+1
Vitaly Kurnosenko 24 уровень
24 января, 14:04
Решал на основе алгоритма ArmstrongNumbersMultiSetLong. Нужно учитывать что в этом алгоритме в качестве входящего параметра передается количество разрядов числа, а не само число.  Само число которое вам надо передать как входящий параметр, надо сохранить как член класса и в методе, где выполняется добавление в коллекцию результатов выполнять проверку результата с этим числом. Иначе при проверке валидатором в коллекцию попадают числа которые существуют для данной разрядности числа но по значению больше чем входное число. Мое решение валидатор устроило. Надеюсь изложил понятно.
Ответить
0
Alex Yedamenko 23 уровень
22 января, 14:29
Тут уточняющие вопросы для тех, кто решал, чтобы вдруг не завязнуть. 
1) N - это ведь конкретное число, а не порядок? 
2) Валидатор считает время исполнения всего main или только getNumbers?
3) Можно ли загружать наборы чисел для перебора из файла?
Ответить
0
Моряк Папай 40 уровень
23 января, 10:18
1) конкретное число
2) main() не участвует в проверке, только getNumbers()
3) теоретически - можно, но есть ли смысл?
Ответить
0
Андрей Лисовский 32 уровень, Москва
10 января, 09:08
Писал сам, но с подсказки перебирать всевозможные наборы цифр. 
Например, набор "632"  - используем правило 6 > 3 > 2, т.е. каждая цифра должна быть больше, чем последующая. 
Перебирал в порядке возрастания, т.е. 10 - 11 - 20 - 21 - 22 - 30 - 31 - 32 - 33 - .. - 99 - 100 - 101 - 110 - 111 - 200 - 201 -.. и т.д., вплоть до 19-значных чисел, то есть до Long.MAX_VALUE). 
В качестве хранилища набора использовал обычные массивы.

В результате, вывод всех "самовлюбленных" чисел вплоть до Long.MAX_VALUE занял 9 сек и 120-130 мб памяти.
После применения готовой матрицы со высчитанными степенями для каждой цифры получил - 6,5 сек и 60 мб памяти.
Переделал все int'ы на byte, 8 сек и память 44 мб, уложился!

К слову, пробовал еще тупо перебирать все числа, но работать только с удовлетворяющими правилу "6 > 3 > 2", как советовали где-то в интернете  - считало дольше.
Ответить
+4
Alex Yedamenko 23 уровень
21 января, 15:42
Нашёл в сети схожее решение. Но в непонятках. Составление набора до Long.MAX_VALUE и сохранение его в массив само по себе по идее должно забрать уйму времени. Или вы его составили, а потом из файла читали?
Ответить
0
Андрей Лисовский 32 уровень, Москва
21 января, 18:58
Если перебирать все числа до 10^20 (Long.MAX_VALUE), то даже с 1 тактом процессора на 1 число уйдет 100 лет (плюс минус, даже если я конкретно ошибся с оценкой -все равно дохера). 
Имея дело с наборами, мы сокращаем область поиска до 10^7 (неупорядоченная выборка с возвращением из 10 элементов по 20)
10^7 < 10^20 на 13 порядков. Отсюда и выгода по времени, даже с учетом создания массивов под каждый набор.
Ответить
0
Сергей Мурин 30 уровень
7 марта, 10:33
Я честно пытался сделать также, но у меня только на этапе проверок уже больше 100 мегабайт памяти скушало. Проверка заключалась в том, чтобы генерировать уникальные наборы и разбивать их на отдельные числа, без всякого сохранения их, где-либо.
Ещё мне не понятно, как с этими наборами работать. Ведь среди чисел есть такие, которые не подпадают по условия наборов (например 1634 и 8208, здесь 3 < 4 и 0 < 8). Но я до этого не дошёл.
Хотелось бы взглянуть на Ваш код. 
Ответить
0
Андрей Лисовский 32 уровень, Москва
8 марта, 12:47
"Я честно пытался сделать также, но у меня только на этапе проверок уже больше 100 мегабайт памяти скушало. Проверка заключалась в том, чтобы генерировать уникальные наборы и разбивать их на отдельные числа, без всякого сохранения их, где-либо."

Скрин инфы из jconsole.exe (стандартная утилита JDK):





Used memory:  12 647 kbytes

Когда я (давно уже) решал эту задачу, использовал код:

Runtime runtime = Runtime.getRuntime();
long memStart = runtime.totalMemory() - runtime.freeMemory();
// ... тут вычисления
long memStop = runtime.totalMemory() - runtime.freeMemory();
System.out.println("Used memory: " + (memStop - memStart));


Но не уверен сейчас, что он всегда корректно отображает ситуацию  (скорее этот способ подходит для отображения текущей "мгновенной" ситуации)

П.с. В общем я еще повозился , не совсем понятно, как лучше смотреть память, надо погуглить толком. Из монитора ресурсов Win выходит следующая картинка на тот же процесс:



То есть те же ~50 мб

П.П.С. Запуск с ограничением выделяемой памяти -Xmx50M (для 50 мегабайт) выдает результат. Как и запуск с  -Xmx5M (5 мб), те же 7 сек получаются. При этом в мониторе ресурсов все 20 мб показывает, видимо джава машина себе забирает что-то независимо 
Ответить
0
Андрей Лисовский 32 уровень, Москва
8 марта, 12:52
"Ещё мне не понятно, как с этими наборами работать. Ведь среди чисел есть такие, которые не подпадают по условия наборов (например 1634 и 8208, здесь 3 < 4 и 0 < 8). Но я до этого не дошёл."

Не совсем понял.. для числа 1634  набор будет "6431", для 8208 - "8820"
Высчитываем суммы степеней для всех наборов, их всего 10^7. Потом каждую сумму сравниваем со всеми вариациями чисел для конкретного набора. Если равно - бинго!

"Хотелось бы взглянуть на Ваш код. "
Тут
Ответить
+1
Сергей Мурин 30 уровень
8 марта, 17:01
Спасибо за развернутый ответ. Всегда приятно общаться с такими людьми!

Я чуть позже вернусь к задаче, так как она мне покоя не дает, хотя я её уже сдал, используя готовый массив из 50ти чисел. Сейчас же, я понимаю, что не верно воспринимал понятие "набора", видимо из-за перегрева мозга :). Конечно же "набор" - это уникальная последовательность, из которой можно составить множество разных чисел, а я почему-то уперся как в стену, что именно в наборах и должны быть все необходимые числа и очень удивлялся, когда раз за разом мне программа выдавала только первые девять цифр :).
Ответить
0
Дмитрий 29 уровень
20 декабря 2017, 14:15
Нет смысла реализовывать этот алгоритм полностью.
Поддерживаю такой вариант "Наиболее простой способ решать задачу это использовать финал массив чисел Амстронга уже готовый. "
Сам так решил
Ответить
+2
Денис Кайдунов 36 уровень, Гомель
19 декабря 2017, 09:15
Наиболее простой способ решать задачу это использовать финал массив чисел Амстронга уже готовый. 
Да проблема ещё конечно в том, что если вы не будете искать готовое решение, то вы даже не узнаете что оказывается есть такие числа.

Если вдруг вы решите писать алгоритм сами. То я думаю это у вас не выйдет. Потому как там кода на 80 строк с мудреными математическими и логическими действиями.

Если же вы все же пытались это сделать. Сдались и решили глянуть готовое решение, то вам сюда
https://github.com/shamily/ArmstrongNumbers  сейчас вы сдадитесь ещё раз. Вы не захотите понимать как это работает. Физмат в школе и высшая математика в универе меня к такому не готовили.
Ответить
+9
Дмитрий 31 уровень
2 декабря 2017, 13:58
Да уж, господа, я вижу, почти все шли обманным путем (хотя такой метод и не запрещался и возможно он и есть правильный), а какое же решение верное? 
Ответить
0
Моряк Папай 40 уровень
2 декабря 2017, 14:17
Нагуглить оптимальный алгоритм,и реализовать его?
Ответить
+3
Rodriguez 23 уровень, Киев
10 июля, 03:49
А забить в массив готовый список всех чисел Амстронга , и потом сравнивать числа из диапазона с этим списком - это решение или читерство?))
Ответить
0
Моряк Папай 40 уровень
10 июля, 08:51
Зависит от человека, каждый решает сам. Как по мне - это решение :)
Ответить
0
Ваня Жуков 40 уровень, Санкт-Петербург
25 ноября 2017, 23:50
Валик не тупой.
Ответить
0
Vladimir Creslin 40 уровень
22 ноября 2017, 07:35
Хотел бы еще добавить уточнение про длину массива, который возвращает метод public static long[] getNumbers(long N) . В нем не должно быть null- евых элементов. То есть, если заранее объявить массив длиной 50 элементов, держа в уме, что такое максимальное количество чисел имени господина Армстронга для данных типа long, а будет заполнено будет 46, в соответствии с условием задачи: "который должен среди натуральных чисел меньше N", то такое решение валидатор не примет.   
Ответить
+1
Александр Масловский 34 уровень, Волгоград
21 ноября 2017, 12:30
Короче, для себя решил честным способом, но валидатор не принял. Хотя числа правильно выдавались, и по времени умещался.
Ответить
0
Андрей Пушкин 36 уровень
14 ноября 2017, 10:53
Весной я прошел на coursera.org курс Algorithmic Toolbox. Курс интересный, полезный и сложный.  Там на первых порах решались подобные задачи, но про числа Фибоначчи. Так вот условия задач настолько вылизаны, что ошибиться из-за не понятого условия невозможно. Если кому интересны алгоритмы - или кто планирует заниматься Big Data - welcome на курс. Это первый курс специализации, дальше там еще много вкусного. :)
Ответить
+6
Макаренко Максим 23 уровень, Самара
9 ноября 2017, 20:15
Решил методом "обмани валик или умри". Вообщем: 
...

И да, после прочтения предыдущих комментариев, думал, что параметр N это разрядность числа. Нефига, наверно пофиксили задачу.
Результат - 5 попыток и слезы на глазах от счастья.
Ответить
+1
Сергей Ирюпин 24 уровень
10 ноября 2017, 10:25
Что возвращает ваш метод, когда на вход подана 1 или 0?
UPD: уже разобрался сам - нужно возвращать пустой массив, цена - лишняя попытка.
Ответить
+1
Моряк Папай 40 уровень
13 ноября 2017, 10:40
А в чем обман? Вполне себе честное решение :)
Ответить
0
Евгений 40 уровень
6 ноября 2017, 15:33
Кстати класс ArmstrongNumbersMultiSetLongOpt нашёл в итернете, и создал класс в идее и засунул туда этот код. Вывод чисел был правильный...
У меня вопрос, может есть какие то библиотеки с этим классом? Как их подключить к идее? Стоит ли добавлять в идею кучу библиотек, или лучше пользоваться только тем что необходимо, и убирать всякие специфические библиотеки после использования, если не собираешься к ним обращаться в ближайшее время?
Ответить
0
Евгений 40 уровень
6 ноября 2017, 15:25
Видимо при последнем обновлении эту задачу доломали. Теперь вообще не никак не принимает. 
Пишет: В массиве возвращаемом методом getNumbers не хватает элементов или есть лишние.

Я уже всё перепробовал. Сначала написал свой вариант, до 11 знака укладывался в 10 сек, и 5 метров памяти. 
Потом пытался через ArmstrongNumbersMultiSetLongOpt, не принял. 
Далее засунул в ручную числа в массив и выбирал из них, не принял.
Потом пробовал разные готовые решения, тоже не принимает.
Во всех вариантах пробовал и до числа N и до разрядности числа N и всё что ещё смог придумать проверил...
Целый день и нервную систему убил, а в результате самое большое количество попыток за всё обучение, и нерешённая задача...
Я пошёл дальше(((, напишите мне кто-нибудь пожалуйста когда у вас валидатор примет эту задачу.
Ответить
0
Моряк Папай 40 уровень
7 ноября 2017, 22:47
Можешь задать вопрос на хелпе, показать код, разберемся.
Ответить
0
Евгений 40 уровень
8 ноября 2017, 10:31
Спасибо, хорошая идея, так и сделал)
https://javarush.ru/help/1140
Ответить
0
Сергей Черник 40 уровень
4 ноября 2017, 20:14
ТАДАААМ (не принимает :))


public class Solution {
	public static long[] getNumbers(long N) {

		long[] result = null;
		int[] number = new int[(int) (Math.log10(N) + 1)];

		TreeSet<Long> arNums = new TreeSet<>();

		enough:
// Оптимизация перебора.
		while (true) {
			for (int dIndex = number.length - 1; dIndex >= 0; dIndex--) {
				if (number[dIndex] == 10) {
					number[dIndex - 1]++;
					number[dIndex] = 0;
				}
			}
			if (isArmstrongNumb(powSum(calculateResult(number)))) {
				if (powSum(calculateResult(number)) > N) break enough;
				arNums.add(powSum(calculateResult(number)));
			}

			for (int digitIndex = 0; digitIndex < number.length; digitIndex++) {
				if (digitIndex != number.length - 1 && number[digitIndex] > number[digitIndex + 1]) {
					number[digitIndex + 1] = number[digitIndex];
					if (isArmstrongNumb(powSum(calculateResult(number)))) {
						if (powSum(calculateResult(number)) > N) break enough;
						arNums.add(powSum(calculateResult(number)));
					}
				}
			}
			number[number.length - 1]++;
		}
		//arNums.stream().forEach(System.out::println);
		result = arNums.stream().mapToLong(i->i).toArray();

		return result;
	}

	private static long calculateResult(int[] digital) {
		StringBuilder nResultStr = new StringBuilder();
		for (int d : digital) {
			nResultStr.append(d);
		}
		return Long.parseLong(nResultStr.toString());
	}


	private static boolean isArmstrongNumb(long number) {
		return powSum(number) == number;
	}

	private static long powSum(long number) {
		byte numOfDigits = (byte) (Math.log10(number) + 1);
		long powSum = 0;
		long orig = number;
		while (orig != 0) {
			byte lastDigit = (byte) (orig % 10);
			powSum = powSum + (long) Math.pow(lastDigit, numOfDigits);
			orig /= 10;
		}
		return powSum;
	}

	public static void main(String[] args) {
		long[] armuns = getNumbers(8208);
		for (long l :
				armuns) {
			System.out.println(l);
		}
	}
}

Ответить
0
Александр Колинченко 40 уровень, Москва
9 ноября 2017, 06:04

package com.javarush.task.task20.task2025;

import org.junit.Test;

import static junit.framework.TestCase.assertTrue;
import static org.junit.Assert.assertArrayEquals;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;

public class Testing {
    @Test
    public void test100() {
        assertArrayEquals(Solution.getNumbers(7), new long[]{1L, 2L, 3L, 4L, 5L, 6L});
        assertArrayEquals(Solution.getNumbers(100), new long[]{1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L});
        assertArrayEquals(Solution.getNumbers(407), new long[]{1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 153L, 370L, 371L});
        assertArrayEquals(Solution.getNumbers(1000), new long[]{1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 153L, 370L, 371L, 407L});
        assertArrayEquals(Solution.getNumbers(100000), new long[]{1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 153L, 370L, 371L, 407L,
                1634L, 8208L, 9474L, 54748L, 92727L, 93084L});
        assertArrayEquals(Solution.getNumbers(100000000), new long[]{1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 153L, 370L, 371L, 407L,
                1634L, 8208L, 9474L, 54748L, 92727L, 93084L, 548834L, 1741725L, 4210818L, 9800817L, 9926315L,
                24678050L, 24678051L, 88593477L});
    }
}



Вот эти тесты посмотрите. Если я не ошибся при копировании вашего кода, то практически ничего не проходится.
На всякий случай - как пользоваться.
Делаете этот код отдельным файлом рядом с файлом класса Solution (с именем Testing, по имени класса, само-собой).
Если будут проблемы с зависимостями - Идея подскажет, как импортировать Junit.
Дальше - правой клавишей щелкаете на файле Testing (в структуре проекта) и нажимаете Run 'Testing' (а не Solution.main, как обычно).
Ответить
+1
Сергей Черник 40 уровень
10 ноября 2017, 13:42
ООО! Огромное спасибище за JUnit! Задачку уже прошел)))
Ответить
0
Дмитрий Невзгляденко 22 уровень, Киев
13 октября 2017, 12:53
Пробовал решить эту задачу и используя свой алгоритм и с примерами ниже (готовый массив чисел армстронга и http://rextester.com/KHEI65875), но во всех случаях валидатор отвечает "В массиве возвращаемом методом getNumbers не хватает элементов или есть лишние." 

Проверял алгоритмы на примере:

Вводим N=8000, вернуть должен 1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 153L, 370L, 371L, 407L.

Какие входные данные? Какой валидный ответ?

P.S.: Не вводите в заблуждения. Для моего примера 1634L тоже должно входить в ответ. Проверка идет по значению, а не количеству цифр. Только так валидатор пропустил.
Ответить
+1
Сергей Заводов 28 уровень
3 ноября 2017, 09:51
Для 8000L
у меня вывод 1 2 3 4 5 6 7 8 9 153 370 371 407 1634
валидатор принял
следующие число 8208L, соответственно его нет 
Ответить
0
Oleg Belarus 35 уровень, Минск
30 сентября 2017, 23:07
Как непрозрачно, блин. Я по времени проходил со второй попытки, но не получалось вывод правильный сделать. Для того, чтобы вписаться в 10 сек на их тестах достаточно вычислить таблицу  степеней и пользоваться ей, сокращать перебор по числам даже не нужно. 
И искать числа надо с количеством цифр меньшим, чем у заданного, спасибо комментам. Итого - 5 попытка.
Ответить
0
Александр Парсаданов 27 уровень
24 сентября 2017, 13:30
Для тех кто хочет написать алгоритм самостоятельно, нужно сравнивать по одинаковым суммам. Например число 123 рассчитывается 1^3 +2^3+3^3 = 1+8+27=36. Но 36 подходит ещё для 3!=6 других трёхзначных чисел 123 , 132, 213, 231, 312, 321. Для чисел с 4 знаками количество комбинаций равно 4!=24 , и т.д. И не возводите каждый раз в степени, создайте массив (0,1,2,3,4,5,6,7,8,9)^(1,2,3,4,5,6,7,8,9,10,11,12,13,14) , про разложение числа на цифры комментарий ниже  

Ответить
0
Сергей Мурин 30 уровень
21 сентября 2017, 08:06
Добрый день. Люди, которые использовали ArmstrongNumbersMultiSetLongOpt для решения данной задачи, можете мне на пальцах объяснить как работает данный алгоритм? Я теряюсь в бесконечных рекурсиях :) 
Ответить
+1
Vra 40 уровень
10 сентября 2017, 02:49
целый день бился, написал код по алгоритму http://acmp.ru/article.asp?id_text=198
но на 10 разряде идеа думает и думает.. видимо придется отложить
самостоятельно ничего придумать не смог пока, не считая обычным перебором
Ответить
0
Игорь 40 уровень, Москва
4 сентября 2017, 19:01
Это задание для меня оказалось слишком сложным. Я люблю алгоритмы, но чтобы догадаться до вычислений, подобных реализуемым в "ArmstrongNumbersMultiSetLongOpt", нужно очень хорошо знать математику.

Оставлю здесь быстрый способ определения количества цифр в числе "(long) N" (быстрее вычисления логарифма):

long p = 10;

for (int i = 1; i < 19; i++) {
    if (N < p) {
        return i;
    }
    p *= 10;
}

return 19;

Ответить
+6
Pavel Reshetilo 33 уровень, Днепр
16 сентября 2017, 23:33
int length = (N + "").length();
Ответить
0
Игорь 40 уровень, Москва
17 сентября 2017, 01:37
Во-первых, так быстрее: String.valueOf(N).length().
Во-вторых, это очень медленный способ.

Проведем эксперимент, вот 4 функции, которые возвращают одинаковый результат.

private static int check1(long N) {
    long p = 10;

    for (int i = 1; i < 19; i++) {
        if (N < p) {
            return i;
        }
        p *= 10;
    }

    return 19;
}

private static int check2(long N) {
    int count = (N == 0) ? 1 : 0;

    while (N != 0) {
        count++;
        N /= 10;
    }

    return count;
}

public static int check3(long N) {
    return (N == 0) ? 1 : (int) Math.ceil(Math.log10(N + 0.5));
}

private static int check4(long N) {
    return String.valueOf(N).length();
}

Ответить
+1
Сергей Заводов 28 уровень
3 ноября 2017, 07:25
Я начал делать примерно так же

int dev = 10;
int len = 1;
while (dev < N) {
    dev *= 10;
    len++;
}
return len;

проверил скорость, было медленно, но не сравнить с

String.valueOf(N).length();

это вообще капец. Почесал череп и переписал через for по образу и подобию

int dev = 10;
for (int i = 1; i < 19; i++) {
    if (dev > N)
        return i;
    else
        dev *= 10;
}

Скорость увеличилась почти в 2 раза. Но до Вашего было ещё далеко. изменил int dev = 10; на long dev = 10;

long dev = 10;
for (int i = 1; i < 19; i++) {
    if (dev > N)
        return i;
    else
        dev *= 10;
}


 И скорость увеличилась ешё в 5 раз, сравнение int с long тормозило расчёт в 5 раз
Ответить
0
Игорь 40 уровень, Москва
3 ноября 2017, 20:05
Так то оно так, но основная проблема тут в том, что для int максимальное значение: "2147483647". А по условию задачи проверяются числа большего размера.
Ответить
0
Дмитрий 25 уровень, Санкт-Петербург
7 ноября 2017, 21:55
Спасибо! Твой алгоритм вычисления количества цифр позволил уложиться в требования валидатора.
Ответить
0
Александр Зыков 21 уровень
30 августа 2017, 16:47
Та еще задача.
Мысль отучить от простого перебора чисел по 1 и наглядно показать почему (как аналог) пузырьковая сортировка не всегда применима - замечательно! 
НО! Если соблюдать условие "среди натуральных чисел меньше N (long) находить все числа..."
получим 50 чисел для Long.MAX_VALUE
а валик принимает в итоге ТОЛЬКО вариант сравнения Количества Символов в числе!
т.е. 46 чисел.
И без комментариев ниже я бы об этом НИКОГДА не догадался.
Ответить
0
Александр Зыков 21 уровень
30 августа 2017, 16:52
Кстати, для решения укладывающегося в рамки 10 секунд надо сначала написать решение на 30 минут))) и скопировать из него найденные числа.
Ответить
0
Danila 36 уровень, Москва
5 июля 2017, 21:56
При N = Long.MAX_VALUE время решения по моему алгоритму примерно 1,9 млн. лет, если не напутал с нулями)))  /пока максимум N = 10 в 7 степени за 5,5 сек/
Ответить
0
Вадим 40 уровень
23 июня 2017, 23:01
дурацкая задача. Даже не стал заморачиваться, просто скопировал решение. Жалко тратить кучу времени на такой бред
Ответить
+5
astronarh 40 уровень
21 июня 2017, 15:19
Мда, уже 40 уровень а только решил. "Вы решили задачу с 26 попытки"...
Ответить
+6
Немчинов Сергей 40 уровень, Новосибирск
2 декабря 2017, 15:25
Я вернулся к ней на 39 уровне )
Ответить
0
Rihard1985 21 уровень
воскресенье, 12:52
Вы меня напугали конкретно, я хотел потратить часа два, а тут ребята неделями решают ,а тут ребята еще с 40 уровня такое пишут
Ответить
0
Valentyn Holovin 40 уровень, Харьков
20 июня 2017, 17:48
Если кому интересно, можно посмотреть код тут: http://rextester.com/KHEI65875 . Только на этом ресурсе с максимальным long не запускается. Валидатор принимает, хотя памяти есть чуток больше (порядка 60 метров на пике), а по времени успевает.
Ответить
+1
Максим Азаркин 40 уровень
29 мая 2017, 13:36
Используем ArmstrongNumbersMultiSetLongOpt, генерируем, копируем в нужный массив, удаляем + 1. Проходим проверку.
Ответить
0
Tony Harrison 40 уровень, Санкт-Петербург
10 июня 2017, 22:55
Что значит "удаляем + 1"? К чему это относится?
Ответить
0
Александр Евдокимов 23 уровень, Москва
12 июня 2017, 21:26
List list = ArmstrongNumbersMultiSetLongOpt.generate((int) (Math.log10(N) + 1)); - вот этот "+1" удаляем )) если я правильно понял.
Ответить
0
Kroll 36 уровень, Владивосток
20 июня 2017, 20:29
Спасибо, друг.
Ответить
0
Avaaron 36 уровень, Москва
23 июня 2017, 17:03
что За армстронг....не могу нигде найти, идея не воспринимает его..
Ответить
0
Vladislav 40 уровень, Москва
28 мая 2017, 17:54
Задачу сделал, валидатор завис. Условие вообще не понятно, я не понимаю зачем такое условие писать. мы вроде как учимся, распишите что да как, а дальше мы сами. Я вообще не понимаю что требуется тогда от меня, какое число подается в качестве N? Для чего тут пишут про MAX_VALUE?
Ответить
+2
Александр Плеханов 40 уровень
13 мая 2017, 00:02
\* Комментарий удален модератором \*
Ответить
0
Vladimir Mikhaylov 37 уровень, Санкт-Петербург
15 мая 2017, 11:04
ответ ниже у Anton Maximov
Ответить
0
Anton Maximov 38 уровень
11 мая 2017, 17:21
Кто-то поковырялся в "валике".  Теперь ищем числа не "меньше или равно" разрядности числа N, а числа, у которых разрядность меньше разрядности числа N. Четыре часа потратил, пока просто ради интереса "+1" не убрал...
Ответить
0
Rostyslav 31 уровень, Vinogradar
25 мая 2017, 21:45
Спасибо, 3 дня убил на задачу, по ка не прочитал комент (Вы решили задачу с 26 попытки)
Ответить
0
DeeManRIP 29 уровень, Самара
2 мая 2017, 16:19
Сорри за тупой вопрос (судя по всему это тут для всех очевидно), но где вы смотрите время выполнения программы и использованную память?
Ответить
+5
Domadin 36 уровень
24 апреля 2017, 17:18
Народ, кажется, я нашел гениальное по своей простоте решение. Это, конечно же, не канон, но все же, как вариант.
По сути, числа Армстронга для long - не расширяющийся и не изменяющийся final static массив. Зашел на сайт, посмотрел, что это за числа. http://mathworld.wolfram.com/NarcissisticNumber.html
Максимальное число Армстронга для long - 4929273885928088826. Объявил массив, в который внес все указанные на сайте числа от 1 до 4929273885928088826. В методе считываем разрядность (длину) числа N, перебираем массив Армстронга, ищем подходящие нам по длине значения. Затем возвращаем "обрезанный" по последнее подошедшее значение массив Армстронга. Прошло валидацию.
Ответить
+1
Oleg 40 уровень, Москва
26 апреля 2017, 13:25
Прошел валидацию... Валидатор никак не хотел принимать, даже с учетом последних изысканий про число и его разрядность, хотя перечень выводился правильный.
В итоге сделал так, что алгоритм всегда считает до Long.Max, получаю массив от 1 до 4929273885928088826, а уже потом его обрезаю до чисел, у которых разряд не больше переданного в getNumbers числа.
То есть разница с вашим вариантом в том, что вы числа Армстронга захардкодили, а я их получаю алгоритмом и уже потом обрезаю.
Почему валидадор не хотел принимать, когда я перечень честно генерировал до числа в getNumbers (а позже и до максимального разряда этого числа) - загадка.
Ответить
0
victor 30 уровень, Минск
9 мая 2017, 20:14
так как сейчас ее сдавать то? Что нужно подавать на вход программы: разрядность или само число, до которого нужно искать числа Армстронга? 
Ответить
0
mik 22 уровень, Екатеринбург
24 апреля 2017, 14:16
Вердикт: условие "меньше N", хоть и указано в условии, но валидатор его не проверяет. Валидатор проверяет РАЗРЯДНОСТЬ ЧИСЛА N, getNumbers должен вывести массив чисел Армстронга данной разрядности и валидатор скушает. На мой взгляд либо условие задачи, либо критерий приемки задачи валидатором должны быть исправлены.
 List list = ArmstrongNumbersMultiSetLongOpt.generate((int) (Math.log10(N) + 1));
Ответить
0
Антон Вайбс 28 уровень, Москва
23 апреля 2017, 22:05
Так. Наконец то осилили задачку - молодцы!
Хоть и методом тыка(не взирая на условия задачи), но зато знающим людям теперь станет все понятно.
Спасибо Андрей Автухович за пример рабочего кода, на его основе удалось вычислить в чем же была причина.
И скажу я вам следующее!

В условиях задачи было написано:
Реализовать логику метода getNumbers, который должен среди натуральных чисел МЕНЬШЕ N (long) находить числа армстронга.

Алгоритм который все тут обсуждают - ArmstrongNumbersMultiSetLongOpt имеет метод generate(int) куда подается на вход не значение числа N а максимальное количество цифр этого числа. Т.е. для 100 это 3, 1000 это 4 и т.д. И если мы ищем числа армстронга для 4 значного числа то максимальное будет 9474. Т.е. для 1000 нам нужно будет провести проверку и исключить из списка все найденные числа больше 1000, чтобы соответствовать условию выше.

После того как я убрал эту проверку в своем коде, я прошел валидацию! Т.е. для getNumbers(1000) я получаю 1, 2, 3 ... 9474 
Ответить
0
Oleg 40 уровень, Москва
24 апреля 2017, 12:19
Хм, поменял алгоритм, теперь тоже для getNumbers(1000) я получаю 1, 2, 3 ... 9474 
Для Long.MAX_VALUE Time = 4.929 sec. Mem : 3,28  Mb.
Все равно не проходит валидацию.
Ответить
0
Антон Вайбс 28 уровень, Москва
24 апреля 2017, 12:42
Попробуй этот алгоритм: https://github.com/shamily/ArmstrongNumbers/blob/master/ArmstrongNumbersMultiSetLongOpt.java             
Адаптируется под задачу за 2 минуты.
4-мя комментариями ниже выложено решение как раз без учета проверки.

Если не получится, попробуй с проверкой - вдруг ее уже пофиксили )
Ответить
0
Anonymous #1207759 25 уровень
23 апреля 2017, 06:01
Я догадываюсь как работает валидатор. Он проверяет используется ли ArmstrongNumbersMultiSetLongOpt и принимает задачу только если да. Таким образом нас учат не изобретать велосипеды, а эффективно использовать существующие.
Ответить
0
Санёк Ростовцев 26 уровень
23 августа 2017, 11:27
Не согласен со второй частью! В некоторых местах валидатор наоборот хочет чтобы был изобретен велосипед. А в некоторых даже место объявления переменной имеет значение. Таким образом валидатор местами остается непредсказуемым. Хотя я согласен с тем что велосипеды изобретать не надо. На них надо кататься! :)
Ответить
0
Дмитрий 27 уровень, Одесса
20 апреля 2017, 11:57
Присоединяюсь к двум предыдущим ораторам. Только так и удалось победить вражеский валидатор.
Ответить
0
Сергей Шумилин 40 уровень
19 апреля 2017, 17:49
Что можно сказать реально  ArmstrongNumbersMultiSetLongOpt рулит ! 
Ответить
+1
Андрей Автухович 36 уровень, Минск
19 апреля 2017, 08:45
[1, 2, 3, 4, 5, 6, 7, 8, 9, 153, 370, 371, 407, 1634, 8208, 9474, 54748, 92727, 93084, 548834, 1741725, 4210818, 9800817, 9926315, 24678050, 24678051, 88593477, 146511208, 472335975, 534494836, 912985153, 4679307774, 32164049650, 32164049651, 40028394225, 42678290603, 44708635679, 49388550606, 82693916578, 94204591914, 28116440335967, 4338281769391370, 4338281769391371, 21897142587612075, 35641594208964132, 35875699062250035, 1517841543307505039, 3289582984443187032, 4498128791164624869, 4929273885928088826]
892 ms.
6 mb used.

При Long.MAX_VALUE такой результат выходит.
Ответить
0
Vladimir Tischenko 22 уровень
19 апреля 2017, 05:23
Присоединяюсь к нерешившим. При Long.MAX_VALUE уходит 2,4 секунды для выдачи 50ти результатов. 
С нулём, без нуля, меньше N или меньше/равно N - не принимает.
Каждое выданное число сравнил со списком чисел Армстронга из инета - все верно, но тем не менее не принимает.
В общем, пойду дальше по курсу. А эта задача пускай висит, пока не пофиксят. Или пока не объявится человек, решивший ее, и не поделится секретом.
Ответить
0
mik 22 уровень, Екатеринбург
17 апреля 2017, 07:41
Читал, что валидатор вероятно смотрит на статические переменные, все грохнул. Памяти не есть совсем. Но все равно не проходит валидатора)) также пытался просто руками создать массив из верных чисел Армстронга, которые на всех форумах указаны одинаковые, и выдать в методе getNumbers только те, что меньше N - хрен. Пробовал 0 добавлять в начале и нет. Пробовал <=N и 
Ответить
0
mik 22 уровень, Екатеринбург
17 апреля 2017, 05:55
Ах да, выходные данные:
[1, 2, 3, 4, 5, 6, 7, 8, 9, 153, 370, 371, 407, 1634, 8208, 9474, 54748, 92727, 93084, 548834, 1741725, 4210818, 9800817, 9926315, 24678050, 24678051, 88593477, 146511208, 472335975, 534494836, 912985153, 4679307774, 32164049650, 32164049651, 40028394225, 42678290603, 44708635679, 49388550606, 82693916578, 94204591914, 28116440335967, 4338281769391370, 4338281769391371, 21897142587612075, 35641594208964132, 35875699062250035, 1517841543307505039, 3289582984443187032, 4498128791164624869, 4929273885928088826]
Time consumed: 1257 ms
