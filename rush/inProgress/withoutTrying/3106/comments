
А может кто-нибудь объяснить как сделать обратное? То есть, взять какой-то файл и записать его частями по 4 разным архивам. Просто я не могу разобраться, как данные разделили вообще на 4 части. Это если, например, вместимость полного архива была бы 300, то мы бы в первый архив записали 75 первых байтов, во второй следующие 75 и так далее? Или тут система похитрей?
Ответить
0
cyprusScorpion 37 уровень
23 мая, 12:31
Всего лишь нужно распаковать архивные части файла, и столько "костылей". Неужели вся Java такая? :(
Ответить
+4
Дмитрий 21 уровень, Москва
8 июля, 20:14
Весь валидатор такой.
Ответить
0
artemon 26 уровень, Екатеринбург
27 апреля, 12:15
А у меня уже не первый раз веселье. Сдаю задачу - пишет, что ничего не подходит и всё плохо (страшные красные буквы), а потом задача исчезает из списка и пишет, что она решена. Джава мэджик. :))
Ответить
0
Джонни 24 уровень
25 марта, 09:21
Мне помогло это!
Ответить
+2
Джонни 24 уровень
25 марта, 09:26
Без всякого буфера или temp-ов сразу пишем в файл.
Ответить
+1
Avaaron 36 уровень, Москва
22 марта, 18:25
йа понял....Sequence объединяет все потоки полученные из Enumeration в один, потом мы его оборачиваем в ЗипАутпутСтрим и из него читаем все байты и пишем в ФайлАутпутСтрим.
It`s cool task!! I had a lot of fan!!!!

PS.. Единственное чего я не понял, в данной задаче обязательно получать nextEntry или можно сразу из потока читать??
Ответить
0
Dmitriy F 32 уровень
7 марта, 19:15
Если программа работает корректно, но валидатор не принимает, попробуйте создать zipEntry из ZipInputStream, а потом его закрыть.
Ответить
0
Вадим 35 уровень
7 февраля, 03:08
Не почитал требования, взял только условие, вспоминая то, как не осилил предыдущую задачу про архивы, решил домучать.
Пути засунул в ArrayList, сортировал компаратором, юзал Enumeration и ZipEntry. Тестовые .тхт файлики клеит, интереса ради склеил часовой сет в .мп3 - осилил шустро, реально клеит, реально всё работает, но не прошел валидатор ни по одному пункту. Это, конечно, ожидаемо, но неприятно, что реально рабочие утилиты не проходят, а всякая ересь, которая выдает тонны исключений, валидатором хавается на ура в этом квесте. 
Ответить
+1
Аслан 30 уровень, Москва
5 февраля, 22:44
Вплидацию проходит

public static void main(String[] args) throws IOException {
    String resultFileName = args[0];

    FileOutputStream fos = new FileOutputStream(resultFileName);

    String[] fileNameParts = Arrays.stream(args).skip(1).sorted().toArray(String[]::new);

    Vector<InputStream> inputStreamVector = new Vector<>();

    for (String str: fileNameParts)
        inputStreamVector.add(new FileInputStream(str));

    try(ZipInputStream zipInputStream = new ZipInputStream(
            new SequenceInputStream(inputStreamVector.elements()))){

        ZipEntry entry = zipInputStream.getNextEntry(); // нужны ли эти две строки?

        streamTransfer(zipInputStream,fos);

        zipInputStream.closeEntry();           // не знаю, нужны ли эти две строки.
    }
    fos.close();
}
public static void streamTransfer(InputStream in, OutputStream out) throws IOException {
    byte[] buffer =new byte[1024];
    int countOfBytes;
    while ((countOfBytes = in.read(buffer))>0) {
        out.write(buffer, 0, countOfBytes);
        out.flush();
    }
}

Но знаю как, создать "рванный" архив на Mac OS чтобы уметь тестировать такие задания.
Может кто посоветует чего дельного?
Ответить
0
Maksim Yugai 35 уровень
7 февраля, 04:18
Почему Vector?
Ответить
0
Аслан 30 уровень, Москва
7 февраля, 05:34
он implements List(поэтому надеюсь, бережет порядок)
он (как более старый класс) преобразуется в Enumeration (которого "вытеснил" Iterrator в более новых коллекциях)
А чем он собственно не подходит?
Ответить
0
Maksim Yugai 35 уровень
7 февраля, 06:12
Понятно. Это ты вместо Collections.enumeration(), но в доках написано:

"Unlike the new collection implementations, Vector is synchronized. If a thread-safe implementation is not needed, it is recommended to use ArrayList in place of Vector."
Ответить
0
Динислам Майлюков 32 уровень
10 февраля, 22:10
Сделал также, только с ArrayList (потом попробовал и с Vector) Валидатор принимает. Но! Не работает. В результирующий файл запишется только первый архив, все остальное пропускается. Кто знает почему?
Ответить
0
Александр 35 уровень
12 января, 22:33
Задача на изучение SequenceInputStream и Enumeration. Условие довольно простое - в многотомном архиве упакован только один файл, который надо распаковать с указанным именем (в том числе и путём).
Делаем ZipInputStream, которому передаём SequenceInputStream, которому передаём Enumeration, который в свою очередь делаем на основе отсортированного args[] (кроме нулевого). ZipEntry будет только один, его и записываем в файл, который в args[0].
Ответить
+6
Максим 39 уровень
21 января, 13:57
Конечно, все просто) Только тут хоть одну строчку кода напишешь не так, как хочет валидатор и задача не принимается. В итоге мучаешься, мучаешься. А потом просто копируешь готовое решение и сдаешь задачу. Без комментариев...
Ответить
0
Ярослав 39 уровень, Днепр
26 мая, 18:36
Большое спасибо, наставил на верный путь. Я не мог никак сообразить, как правильно склеивать архивы, а оказывается, что все более-менее просто :)
Ответить
0
Парьев Дмитрий 40 уровень, Нижний Новгород
8 января, 20:43
1. Обязательно сортировать args (ибо части архива приходят в любом порядке)
2. Можно делать и без SequenseInputStream.

ByteArrayOutputStream baos = new ByteArrayOutputStream();
for (int i = 0; i < list.size(); i++) {
    Path part = Paths.get(list.get(i));
    Files.copy(part, baos);
}


где list - это сортированные args.
3. Обязательно в результирующий файл записывать через поток, иначе вылезут ошибки от валидатора)
Ответить
+2
Антон Никольский 33 уровень, Москва
11 января, 22:41
Решение через ByteArrayOutputStream валидатор принимает, но лично у меня при попытке разархивировать фильм на 1,5 ГБ вылезло исключение OutOfMemoryError: Requested array size exceeds VM limit.

При реализации через SequenseInputStream такого нет.
Ответить
0
Парьев Дмитрий 40 уровень, Нижний Новгород
11 января, 23:26
Не удивительно, все таки ByteArrayOutputStream внутри просто массив байт..
Было бы интересно в программу передать куски по 2гб (чтобы на каждый поток пришлась нагрузка сравнимая с нагрузкой на ByteArrayOutputStream в вашем случае), справится ли SequenseInputStream?)
Ответить
0
Антон Никольский 33 уровень, Москва
12 января, 00:43
Видеофайл засунул в архив в виде двух файлов 4,4 ГБ и 0,9 ГБ - SequenseInputStream справился!

3 файла 2 ГБ-2ГБ-1,3ГБ тоже справился.
Ответить
0
Парьев Дмитрий 40 уровень, Нижний Новгород
12 января, 10:43
Здорово! Да, SequenseInputStream классная штука, надо запомнить!)

Как я понял, sequense... подгружает в свой внутренний буфер информацию с диска и переключается между потоками по мере надобности. И поэтому использует память оптимально.
А ByteArrayOutputStream все целиком хранит в памяти. А такой объем великоват для vm.

Нашел классную статью  о потоках.
Ответить
+1
Николай Соколов 31 уровень
12 декабря 2017, 13:46
   Хоть уже и прочел некоторые коменты, все равно решил доделать задачу тем же путем, как задумал. Скидал весь архив в темп файл, затем его разархивировал в указанный файл. Музычка из полученного файла мп3 отлично проигрывается, результат на лицо. Но валидатор не принял задачу ни по одному пункту. Я не только не открыл ни одного потока, но и не закрыл их все, по мнению валидатора. 

    Снова попытался сделать по своему, записал все архивы во временный байтовый массив, а массив уже подсунул в ZipInputStream zips = new ZipInputStream(new ByteArrayInputStream(butes)); , где bytes - байтовый массив со всеми архивами. В общем, задача снова решилась, но уже без копирования архивов во временный файл. Валидатор опять не принял ни по одному пункту, не нашел ни одного потока.

  Теперь сделал через SequenceInputStream. Валидатор тоже не сразу принял, пока не перенес открытие потока на запись в начало программы и не подсунул туда аргумент args[0] напрямую. До этого args[0] было записано в переменную типа Path, которую я потом использовал.
  
  Теперь я не знаю, что мне окончательно помогло, когда задача принялась. Валидатор очень геморная, слепая и тупая вещь!!!

   В общем-то, уже подписку еще на год купил. Можно не лезть из кожи вон ради скорости прохождения...
Ответить
0
Дмитрий Корнеенко 35 уровень, Минск
1 декабря 2017, 14:46
Дебильная задачка. Для выноса мозга и психического расстройства.
1 - ни капельки не понятно что нужно делать из условия. Условие написано понятно только для одного составителя задачки во всём мире. Когда только решил - тогда только что то стало понятно.
2 - Намёки про SequenseInputStream - должны присутствовать в описании задачи, так, как некоторые люди, как я изначально пытаются сами решить задачи, без чтения комментариев и копипаста. На что тратят много энергии и сил.
3 - Потядок в SequenceInputStream - имеет значение. Поэтому надо отсортировать по возрастанию
4 - Если вы думаете, что ZipEntry вам не придётся использовать - вы ошибаетесь. ZipEntry - нужен для того чтобы парескакивать с одного Entry на следующий. И поэтому порядок в Sequency имеет значение. 

PS: побольше бы уважения к рекрутам.   
Ответить
+4
Александр Плеханов 40 уровень
29 октября 2017, 19:13
я делал тесты на текстовом файле , при этом запись  идёт только первого аргумента , остальные не пишутся  , я подозреваю , что дело в том , что они текстовые .  (валидатор принял , на Github такое же решение )

так ли это? 
как переделать программу чтобы писать текстовый файл из нескольких заархивированных файлов?
Ответить
+1
Незнайка 40 уровень, Москва
7 октября 2017, 00:54
Подразумевается что в архив помещен и порезан единственный файл.
Не надо проверять что в архиве могут быть другие файлы.
Ответить
0
Алексей Бородин 24 уровень
22 сентября 2017, 21:47
Пробовал работать с архивом, побитым на части винраром (зип архив, естессно)
На просторах http://info.javarush.ru нашел, что лучше использовать для тестов архив побитый на части 7zip. Так и получилось.

У меня принялся такой порядок
1. Обрабатываем входные значения из args
2. Создаем SequenceInputStream
3. Отправляем его в ZipInputStream
4. после этого работаем с ним так, будто это один целый архив. То есть берем entry, создаем outpustream с нужным именем файла 
5. Пишем в него байты, считанные из ZipInputStream
6. Все потоки "закрываем"
Ответить
+2
Игорь 40 уровень, Москва
12 сентября 2017, 21:08
Значит получил я массив частей. Отсортировал его по имени.
Дальше попробовал решить задачу "в лоб" - соединил все байты кусков в единый zip файл, потом его распаковал. 
Решение рабочее, но валидатор не принял по всем пунктам (вероятно, по причине невозможности на сервере позволить пользователю распаковывать куда-либо файл).
Мне такое решение кажется логичным, оно не быстро работает, но зато не держит много данных в оперативной памяти.
Дальше из комментариев я узнал про SequenceInputStream. Переделал код под него, валидатор все принял.
Вот тут мне не понятно, как это работает. Создается список объектов "inputStreams", при этом не известно, насколько такое решение может быть актуальным, скажем, для миллиона кусочков. Данные из потоков считываются последовательно, поэтому не занимают много памяти. Но сами проинициализированные потоки же должны занимать какую-то часть памяти...
Считаю, что в условие нужно дописать дополнительные требования про то, как делать не нужно.
Ответить
+4
петя 23 уровень, Минск
21 июля 2017, 23:09
по сути элементарно всё но 
в условии забыли написать что нужно решать только через эту шляпу - SequenceInputStream
Ответить
+3
Artem Novikov 40 уровень, Харьков
18 июля 2017, 09:46
На этом уровне для чтения массива байт использовал IOUtils.readFully(zis, Integer.MAX_VALUE, true). В этой задаче и нескольких предыдущих. Влом каждый раз описывать чтение байт. zis это ZipInputStream
Ответить
0
Domadin 36 уровень
5 июня 2017, 16:05
Понял, в чем был косяк. Я неправильно архиватором разбил файлы. Использовал обычную функцию "Разбить файл..." а нужно именно через добавление в архив, выбрать zip и в этом же окне указать опцию разбиения на части. Тогда в файле 001 создается заветный entry.
Ответить
0
Domadin 36 уровень
5 июня 2017, 15:53
Валидатор принимает нерабочее решение. Сначала я сделал через temp-файл. Исходный файл 200 мб, разбит на 3 архива по 70. Все нормально отработало, файл разархивировался и считался, но решение не принялось валидатором ни по одному пункту. Затем написал все, как описано ниже, через Sequence. Итог - программа не работает, т.к. не может достать entry из ZipInputStream-а, но валидатор принял. Кто-нибудь может написать в личку рабочее решение, которое принял валидатор. Просто в моем понимании, чтобы получить entry файла, необходимо для начала где-то объединить части архива в один файл. Это даже написано в требованиях.
Для архивации использовал 7zip.
Ответить
0
Виталий Погодаев 24 уровень
11 марта 2017, 00:56
У меня не принималось решение с Files.copy(zipInputStream, resultFileName). Пришлось делать через FileOutputStream!
Ответить
+3
MaxLich 40 уровень, Санкт-Петербург
31 мая 2017, 18:33
Тоже пробовал так сначала сделать, но что-то вообще не выходило, поэтому сразу начал делать инпутстримами
Ответить
0
Максим Хоменко 36 уровень
9 марта 2017, 22:25
Anonymous #873767, спасибо тебе, зачло, добавил лишь малость - СОРТИРОВКУ по пути файлов, благодаря твоему коду узнал про SequenceInputStream , и код твой довольно быстро работает, правда не совсем понял почему у меня с SequenceInputStream не работало - при чтении даже одного выдавало ошибку, что поток закрыт, так что буду детально разбирать отличия, что у тебя сделано такого, что работает правильно а у меня нет.
Ответить
0
MaxLich 40 уровень, Санкт-Петербург
31 мая 2017, 18:34
+1, рабочий вариант.
Ответить
0
Алексей Плехов 22 уровень
31 августа 2017, 22:32
Валидатор принимает решение, но оно не работает. Протестируйте. У меня вот получается, что как и написал товарищ ниже - второй и следюущие файлы не записываются в выходной поток при попытке получить nextEntry(). Как это обойти не ясно.
Ответить
+1
Anonymous #873767 40 уровень, Москва
2 марта 2017, 09:03
Не понятно, что хотят составители задачи,
вроде у меня разархивируется корректно, но успех только в

Поток для записи в файл должен быть закрыт.

public static void main(String[] args) throws IOException {
        if (args.length < 2) {
            return;
        }

        String resultFileName = args[0];

        List zipParts= new ArrayList<>();
        for (int i = 1; i < args.length; i++) {
            zipParts.add(new FileInputStream(args[i]));
        };

        byte[] buffer = new byte[1024];
        int readByteCnt;
        try(ZipInputStream zipIn = new ZipInputStream(new SequenceInputStream(Collections.enumeration(zipParts)));
            FileOutputStream fileOut = new FileOutputStream(new File(resultFileName))) {

            System.out.println(zipIn.getNextEntry().toString());

            while ((readByteCnt = zipIn.read(buffer)) > 0) {
                fileOut.write(buffer, 0, readByteCnt);
                fileOut.flush();
            }
        }

    }
Ответить
+1
Domadin 36 уровень
5 июня 2017, 16:04
Тут явно не хватает сортировки по названию части архива. zipEntry содержится только в 001 файле. Если на вход придет 002, то из ZipInputStream-a ничего не вытянется инфа.
