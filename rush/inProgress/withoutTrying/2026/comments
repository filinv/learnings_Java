А я сравнивал сумму индексов с суммой предыдущих индексов и с предыдущей строкой. Валидатор съел. sumCoords - сумма предыдущих координат найденной единицы. coordI - i-строка предыдущей найденной единицы.

if (sumCoords!=-1){
    if (((i+j)-sumCoords)>1 | (i-coordI)>1){
            count++;
     }
}

Ответить
0
Rihard1985 21 уровень
воскресенье, 12:56
Чеза дикие задачи по алгоритмам((
Ответить
0
Rodriguez 23 уровень, Киев
10 июля, 03:59
Это какой-то "Сапер" или "Морской бой"))
Ответить
0
Oleg Solovichenko 25 уровень, Екатеринбург
25 июня, 19:57
Создал 3 класса: Точку, Прямоугольник который состоит из точек, и Менеджер прямоугольников который добавляет точку в существующий или создает новый прямоугольник
https://github.com/rymbil/JavaRush/blob/master/JavaCore/task2026/Solution.java
Ответить
0
Артем 26 уровень, Минск
13 июня, 15:41
Решил с первого раза, сравнивая каждую строку с предыдущей. Алгоритм простой и удобный.
1) Первую строку проходим, нас первая строка не интересует, так как ее не с чем сравнивать (i - строки, внешний цикл for, а j - столбцы, внутренний цикл for)

if (i==0)
               { }

2) Во второй и последующих строках сравниваем текущую позицию с оной в предыдущей строке.Если в прошлой строке (i-1) на позиции j была единица, а сейчас ноль, то инкрементируем счетчик и переводим булеву переменную в true, которая нам говорит, что сверху начался прямоугольник. Последующие единицы сверху не воспринимаем, пока булева переменная взведена в true. Как только в верхней строке возник нуль - переводим в false - прямоугольник закончился. Теперь следующая единица сверху снова будет добавлять в счетчик. Данная булева переменная должна обнуляться в false каждый ВНЕШНИЙ цикл, отвечающий за i, то есть номер строки.

if (a[i-1][j]==1 && a[i-1][j]!=a[i][j])
{ if (!wasone){counter++; wasone=true;}}
else if (a[i-1][j]==0)wasone=false;

Всё! этот алгоритм подходит для двумерных массивов любого размера. Единственное, он не учитывает последнюю строку, для нее надо отдельный маленький if с проверкой, является ли строка последней, и отдельная булева переменная

if (i==a.length-1)
              {
              if (a[i][j]==1)
              {
                  if (!lastrow)lastrow=true; counter++;

              }else lastrow=false;
              }



Все манипуляциии проводятся во внутреннем цикле for. 
Ответить
+1
Максим Кобыляков 25 уровень
7 июня, 05:06
очень удобно чуть чуть расширить массив (чтобы не словить выход за границы массива) и потом искать правые нижние углы по границам изначального массива итого 4 фора, один иф 13 строк кода
Ответить
0
Assanali 23 уровень
27 апреля, 15:53
я впервые не захотел сразу чётотам печатать в IDE,
взял тeтрадку, ручку и начал четотам писать)
замутил используя ООП.
Придумал себе класс Corner(int coordinateX, coordinateY)
class Rectangle(Corner topLeft, Corner topRight...)
и всякое такое. 
хотел даже поначалу выложить своё элегантное понятное с поясняющими комментариями, но еще не написанное решение. но поконцове так убого получилось...ну дальше вы знаете
а можно было как тут в комментах пишут Нааамного проще)
Ответить
0
Сергей 28 уровень, Москва
18 мая, 00:27
тоже нахожу первый попавшийся угол, т.е. 1
передаю его в метод который очищает прямоугольник, перезаписывает на 0
дальше ищу угол
основной метод 4 строчки
чистилка тоже 4 строчки
не хотелось 4-этажный for, вынес в метод
Ответить
+2
Александр 36 уровень, Санкт-Петербург
14 апреля, 20:13
Не понятное условие.
Ответить
+5
inlun 21 уровень, Москва
20 марта, 09:55
Решал поиском левого верхнего угла.
Вся проверка заключалась в том чтобы слева и сверху от единицы были нули, либо границы поля.
Задача в 5 строк.
Ответить
+1
Дмитрий Дедков 28 уровень
16 марта, 17:06
Решил путём расширения прямоугольника: если справа и снизу единицы и по диагонали справа снизу от прямоугольника единица, то прямоугольник расширялся вправо+вниз, иначе расширялся или вниз или вправо (если оба варианта возможны, то в сторону большего увеличения площади) или не расширялся вообще. Потом проверка принадлежности точек к прямоугольнику, чтобы новый не создавать и в конце подсчёт созданных
Ответить
0
cyprusScorpion 37 уровень
4 марта, 14:34
Решил по подсказкам, которые имеются здесь, однако всё-таки, как мне кажется, не совсем так, как указано ниже в комментариях.
1. Включил счётчик прямоугольников.
2. Создал массив byte [][] b  на одну строку снизу и на один столбец справа длиннее, чем поступающий в метод getRectangleCount в качестве аргумента byte a[][].
3. Заполнил byte[][] b данными из byte[][] a.
4. Двойным циклом for пошёл слева направо сверху вниз по массиву b, ища такие ячейки с единицами,    у которых соседняя ячейка справа по строке и соседняя ячейка ниже по столбцу заполнены нулями. Поскольку массив b больше по размеру массива a  на один столбец справа и одну строку снизу, и по умолчанию пустые ячейки в массивах байтов заполняются нулями, единицы в крайнем справа столбце и нижней строке без проблем считываются в соответствии с упомянутым выше условием (ищем такие ячейки с единицами, у которых соседняя ячейка справа по строке и соседняя ячейка ниже по столбцу заполнены нулями), поэтому исключение ArrayIndexOutOfBoundsException не выбрасывается, только не забываем, что по массиву b следует проходить не до конца, то есть не захватывать крайний столбец справа и самую нижнюю строку, например, проходить вот так:

for (int i = 0; i < b.length - 1; i++) {
            for (int j = 0; j < b[i].length - 1; j++) { ... }
... 
}

5. Если искомая ячейка нашлась, увеличиваем счётчик на единицу, - прямоугольник найден.

Алгоритм 1 0
                 0
позволяет распознать прямоугольники при прохождении нашего массива массивов слева направо сверху вниз (как он обычно и проходится двумя циклами for, один вкладывается в другой). 
Ответить
+5
Иван 31 уровень
5 февраля, 18:46
Можно же просто проверить, касается ли текущая единичка другой такой же слева и сверху, и если не касается, то увеличиваем счетчик?
Ответить
0
Рамиль Насыров 38 уровень
20 марта, 05:49
я так и сделал - проканало
но нужно еще учитывать когда столбец или строка нулевые
Ответить
0
Alex Yedamenko 23 уровень
26 января, 20:30
Решил коряво, с многими циклами, но с первого раза. Сначала составил список со всеми возможными формами прямоугольника -> запустил цикл по этому списку, в котором для каждой возможной формы составлялся список возможных стартовых координат поиска  -> внутри цикла запустил ещё цикл по списку возможных стартовых координат, ища  в заданной методу матрице совпадения с текущей формой  -> если совпадение найдено, то проверял - нету ли единиц в горизонтальных линиях выше и ниже прямоугольника и в вертикальных линиях правее и левее, если не было, то увеличивал счётчик найденных прямоугольников.   
Ответить
0
Денис Кайдунов 36 уровень, Гомель
19 января, 13:20
Валидатор не проверяет является ли фигура прямоугольником. Берем как должное, что в массиве только прямоугольники.
Ответить
0
Евгений 39 уровень, Санкт-Петербург
26 ноября 2017, 23:22
Наконец смог решить задачку рекурсией)))
Ответить
0
Vladimir Creslin 40 уровень
22 ноября 2017, 08:54
Решил "закрашиванием" найденных прямоугольников нулями.
1.В цикле, в массиве "змейкой" ищем единичку.
2. от единички вправо и вниз, до первого нулика, меняем все единички на нули. 
3. проверяем не прошли ли весь массив. У меня еще дополнительная проверка сделана на количество  единичек в массиве. 
4. Если массив пройден не весь и еще есть единички то продолжаем поиск.
5. результатом будет количество подсчитанных "закрашенных" прямоугольников".
Ответить
+3
Олег 39 уровень
11 декабря 2017, 11:53
Так же решал.
Только я не делал п.3 и соответственно п.4. После найденной единички и заменой на нули, поиск просто продолжается пока не дойдёт до конца массива.

А вообще интересная задача. 
Ответить
0
Igor 34 уровень, Москва
2 января, 13:40
Так же решал через обнуление массива.В цикле если находим 1 запускаю дополнительный метод который меняет 1 на 0 . В метод передаем сам массив а так же i и j элемента равного 1.Если встретил 0 переходим на следующую строку массива прерывая цикл break; Если следующая строка начинается с 0 выходим из метода return; и увеличиваем счетчик прямоугольников на один cout++;
Ответить
0
Anatolii Terela 25 уровень
19 ноября 2017, 02:43
Здесь больше разных прямоугольников для проверки задачи:
         

{1, 1, 0, 0, 0, 0},
{1, 1, 0, 1, 1, 0},
{1, 1, 0, 0, 0, 0},
{1, 1, 0, 1, 0, 0},
{0, 0, 0, 1, 0, 0},
{1, 1, 0, 1, 0, 1}


". Должно быть 5"

Искал правый нижний угол прямоугольника:
// поиск не ставая на крайние правые и нижние ячейки
// поиск по нижнему краю (нижний ряд)
// поиск по правому краю (правая колонка)
// проверка правой нижней ячейки
Ответить
+8
swen922 37 уровень
7 января, 00:13
спасибо за доп. табличку
Ответить
0
Дмитрий 25 уровень, Санкт-Петербург
7 ноября 2017, 23:07
Так одна единица в углу - это прямоугольник? Квадрат имхо.
Ответить
+2
Антон 26 уровень
8 декабря 2017, 08:24
Квадрат это тоже прямоугольник. Просто у него все стороны равны
Ответить
+5
Евгений 40 уровень
7 ноября 2017, 13:26
Не стал заморачиваться,  и написал 40 строчек ифов на все случаи жизни... да, при желании спокойно можно укоротить раза в 3. Но код предыдущего комментатора мне нравится больше)
Ответить
0
Вадим 25 уровень
24 октября 2017, 13:35
/* Комментарий удален */
Ответить
+3
Аслан 30 уровень, Москва
24 ноября 2017, 00:12
Поиск количества левых верхних углов прямоугольника(валидацию проходит)

...

Тут примечателен тот факт что оператор || не вычисляет правое выражение если левое true. Возьмем к примеру выражение:

i==0 || a[i-1][j]!=1


Если у нас i==0, то он не станет больше проверять достоверность выражения a[i-1][j]!=1.
Но если мы поменяем оператор || на оператор |, то он на проверке первого выражения(даже если оно true) не остановится и попробует проверить второе выражение. И при попытке обратиться к элементу массива a[-1][j]  мы получим ArrayIndexOutOfBoundsException. 
Ответить
0
Даниленко Виктор 40 уровень, Днепр
17 октября 2017, 21:05
а я вообще решил взять и написать говнокод решение через массив String[], в елементах которого матчер ищет комбинации единичек, после нахождения любой обнуляем найденное двигаясь вниз по следующим строкам, пока прямоугольник не кончится. Потом двигаем матчер дальше с его позиции, искать и обнулять следующий прямоугольник. 
Решение приняло лол..
Ответить
0
Donatello 32 уровень
6 октября 2017, 22:18
Искал решение по принципу "Найди угол - найдешь и прямоугольник":
1)  Начал с поиска правых нижних углов прямоугольника. Если ячейка a[ i ] [ j ] == 1 И следующая в строке == 0 И ячейка под ней == 0, то нашли прямоугольник. Здесь важно проверить условие, чтобы строка и ячейка не являлись крайними. Иначе получим ArrayIndexOutOfBoundsException.

if (j+1 < a[i].length && i+1 < a.length){
                    if (a[i][j] == 1 && a[i][j+1] == 0 && a[i+1][j] == 0){
                        count++;
                    }


Таким образом, мы охватили все прямоугольники, которые не заступают на последнюю строку и последний столбец.
2)  По той же логике составили цикл для элементов последней строки, за исключением последнего эл-та - для него будет вложено другое условие проверки. 
3)  Далее - для элементов последнего столбца, за исключением эл-та первой строки.
4)  И наконец для последнего эл-та первой строки. 
Ответить
0
LeoJames 40 уровень
28 сентября 2017, 18:17
/* Комментарий удален */
Ответить
0
LeoJames 40 уровень
28 сентября 2017, 18:19
13 лет назад написал сие для игры "Морской бой", школа, паскаль, говнокод... эх, вот это были времена!
P.S. Там снизу идея искать единички и проверять их соседей справа и снизу (если 0 то нижний правый угол). Решил так. 4 строки кода на решение.
Ответить
0
Александр Тимонин 24 уровень, Москва
20 сентября 2017, 19:46
Ребят, если ввести статическую переменную(у меня там был арейлист прямоугольников) в классе Солюшн. То решение может не принять, даже если подсчёт правильный. Только что собрал такую граблю(
Ответить
+1
Dmitry Mityunin 26 уровень, Екатеринбург
15 сентября 2017, 08:37
Понравилась задачка :) 
Решал через ООП. Создал класс точка и класс прямоугольник. 
Через цикл фор кидал i,j единиц в прямоугольник, а тот сам проверял продолжение это какого-либо прямоугольника или нет. 
Если не продолжение, то создавал новый прямоугольник. 
Иначе добавлял точку в прямоугольник. 
Ответить
+2
Vra 40 уровень
11 сентября 2017, 15:36
задача на 10 минут,
2 цикла, 
1 условие на наличие 1цы, 
3 условия на проверку i!=0, j!=0, (не первая строчка, не первый столбец), 
       внутри 3 условия на проверку угла..

после предыдущей задачи прям отдых какой то, а прошлую так и не решил :)))
Ответить
+3
Karahanid 40 уровень, Алматы
22 августа 2017, 21:18
На таких задачах хорошо раскачивается скилл интеллект. :)
Ответить
+1
Илья 25 уровень, Москва
11 августа 2017, 15:13
Жутко коряво на мой взгляд но коротко и работает: сначала посчитал единицы в массиве через двойной фор (получилось count= 9), потом во второй паре for-ов вычитал из count по единице при условии что  проверяемая позиция это единица справа и/ или снизу от проверяемой позиции то же единицы.
Ответить
0
Anonymous #1068415 31 уровень, Воронеж
27 июля 2017, 17:55
Искал верхний левый угол - на 20 строк алгоритм (хотя можно уложиться и в меньшее количество строк, но только за счёт лишних громоздких проверок). Приятная задача.
Ответить
0
AlexandeRogov 40 уровень, Москва
21 июля 2017, 18:06
Прикольная задача))
Записал в массив со всех сторон нули и нашел все верхние левые углы прямоугольника(верхняя ячейка 0, слева ячейка 0, и сама ячейка единичка).
Сам алгоритм на 30 строчек кода.
Задачу приняло только с 10 попытки, только из-за того что в метод getRectangleCount должен поступать двумерный массив который мы проверяем (не измененный), а я его менял до самого метода (в методе main), поставил изменение массива в сам метод и велосипед поехал xDD.
Ответить
0
Сергей Зимовец 31 уровень
16 июля 2017, 19:18
классная задача!!!!
Ответить
0
Serj Ardovic 34 уровень, Москва
9 июля 2017, 16:39
Т.к. прямоугольники друг друга не касаются, проверка по любому из углов проходит. 
Ответить
+1
Вадим 40 уровень
24 июня 2017, 10:12
Прикольная задача. При проходе массива проверял значение элемента. Если 0 - continue, если нет -
 менял 1 на -1, а потом проверял верхнего и левого соседей. Если есть среди них -1 - значит тот же прямоугольник, а если нет таковых - значит новый. Написал два простеньких вспомогательных метода для проверки соседей (не хотелось тулить в основной цикл, т.к. нужно обрабатывать нулевые индексы, иначе - ArrayOutOfBoundsException)
Ответить
0
iseverin 35 уровень, Минск
9 июня 2017, 15:36
Думал над решение полчаса, придумал несколько вариантов, но как-то не оптимально получалось, прям бинди на лбу начинала проступать. Объяснил на пальцах жене, совершенно далекой от программирования, сказала что надо просто искать нижние правые углы, их не может быть больше, чем самих прямоугольников. Итого за один проход все найдено и код - проход по массиву + 3 условия:
         
Доволен за решение и за жену :)
P.S.: Бинди - индийская точка на лбу.
Ответить
+6
Александр 35 уровень
18 июня 2017, 14:53
Твоя жена - гений. А вообще можно искать абсолютно любые углы. Мой поклон твоей жене.
Ответить
0
Григорий Грицюк 31 уровень
9 июля 2017, 01:06
Спасибо за подсказку! 
Ответить
0
Karahanid 40 уровень, Алматы
22 августа 2017, 21:14
Твоя жена просто ЗОЛОТО! Береги ее как зеницу ока. Поцелуй ее за меня XD
Ответить
+1
Роман Петров 30 уровень
25 мая 2017, 01:54
Не додумался про затирание. Но решил другим способом. Начало такое же вот только вместо затирания я создаю объекты прямоугольника не меняя массива. И если попадаю на элемент прямоугольника, то иду дальше по массиву. Если найденный элемент не принадлежит прямоугольникам, которые уже найдены, то создаю новый прямоугольник и ищу его вершины
Ответить
0
Ivan 20 уровень
16 ноября 2017, 02:17
Я такое же решение заимплементил! :)
Но у меня его валидатор не принимает. :(
Ответить
0
Anonymous #1168137 31 уровень, Кокшетау
22 мая 2017, 11:49
Да не нужно это всё!!! Не теряйте времени, учите Джаву, а не математику.
Задайте себе цель, и идите к ней, если задача не целевая, плюйте на неё На гит-хабе есть все решения для "педпнтичных качальщиков персанажей". Вся расса роботов заржавеет, пока вы тут всю эту каку пережуёте. Материи вам точно хватит на весь полёт, заправляя свой корабыль лиш целевыми задачами!!!
Ответить
+3
Sprw 29 уровень
10 октября 2017, 22:04
подобные задачки любят задавать на собеседованиях :/
Ответить
+1
Петр 22 уровень
30 апреля 2017, 21:43
вот эта инициализация 
1, 1, 0, 0,
1, 1, 0, 0,
1, 1, 0, 0,
1, 1, 0, 1
это нам как бы уже нарисовали два прямоугольника на плоскости, можно единички обвести, и получатся два прямоугольника - один большой, 4 клетки вверх, 2 клетки вправо, другой маленький из одной клеточки

для тестирования можно, вообще так написать:

1, 1, 0, 0, 1, 0
1, 1, 0, 0, 1, 0
1, 1, 0, 0, 0, 0
1, 1, 0, 1, 1, 0
то есть ,если обвести единички - получится три прямоугольника, их и надо найти алгоритмом.
Ответить
+4
Alexey Malakhov 37 уровень, Москва
20 апреля 2017, 17:44
Не очень понимаю условие, может кто пояснит? 
Почему тут 2 прямоугольника? Я правильно понимаю, что первый и второй ряды по вертикали с  "1" - это первый прямоугольник, а второй это правый нижний угол с одной "1" ? 
Ответить
+1
Roman_UA 41 уровень, Киев
25 апреля 2017, 13:00
Да
Ответить
+1
MURS 35 уровень, Киев
4 апреля 2017, 11:00
Кто-нибудь, объясните, пожалуйста, как вообще таким  образом можно иницилизировать двумерный массив?
Ответить
0
Anonymous #1068415 31 уровень, Воронеж
27 июля 2017, 17:59
В java нет двумерных массивов. В задаче у нас массив одномерных массивов, а не матрица.
Ответить
0
Кирилл Кириллов 32 уровень, Екатеринбург
1 апреля 2017, 20:04
а я просто цикл сделал с 5-ю if 4-е из которых вложенны в пятый. проверял есть ли выше на один элемент 0 и есть ли левее ноль от текущего. плюс учесть что это может быть начало массива
Ответить
0
Алексей Дмитревский 31 уровень, Москва
8 марта 2017, 00:02
Работающий вариант решения:
Цикл по строкам {
  Цикл по столбцам {
    Находим элемент матрицы, равный единице {
      каунт++
    }
    Проверяем на сколько элементов вправо от найденного есть единицы без разрывов
    Проверяем на сколько элементов вниз от найденного есть единицы без разрывов
    Цикл по строкам и столбцам для зануления всех найденных элементов прямоугольника
  }
}
    
Ответить
+5
Bazz 29 уровень
1 апреля 2017, 19:55
Спасибо! Сам никак не мог придумать верный алгоритм
Ответить
0
Domadin 36 уровень
22 апреля 2017, 22:27
Спасибо за подсказку про обнуление пройденных элементов, сам что-то не мог додуматься...
Ответить
+2
Igor 34 уровень, Москва
2 января, 12:59
Хороший вариант. Я по элементно проверял если =1 затирал на 0
